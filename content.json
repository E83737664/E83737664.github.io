{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Neoth","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2020-10-06T13:34:41.000Z","updated":"2020-10-06T13:34:41.665Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-06T13:36:30.000Z","updated":"2020-10-06T13:36:30.492Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-06T13:36:19.000Z","updated":"2020-10-06T13:36:19.880Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-10-06T06:30:45.550Z","updated":"2020-10-06T06:30:45.551Z","comments":true,"path":"2020/10/06/hello-world/","link":"","permalink":"http://example.com/2020/10/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"考研规划","slug":"考研规划","date":"2020-01-06T08:23:16.000Z","updated":"2020-10-06T15:12:04.904Z","comments":true,"path":"2020/01/06/考研规划/","link":"","permalink":"http://example.com/2020/01/06/%E8%80%83%E7%A0%94%E8%A7%84%E5%88%92/","excerpt":"","text":"基础阶段（3-6月）数学 高数：杨超高数基础班+课本和张宇十八讲的注意点部分+1800题基础部分 现代：李永乐线代基础班+线性代数辅导讲义 1800：平均一周做完一章稍微多一点（一章100题）视频：一周一章多一点（一章6小时左右） 英语 曲根10000过完 onenote复习 新题型和作文的视频 4085月初-6月末 60t： 操作系统的课本复习加笔记整理+王道的所有题目 计算机网络王道视频+王道题目+计网topdown重点内容理解 清航四科视频 强化阶段（7-9月）数学：7月初-7月末30t：7月初-7月末30t： 7月初-7月末30t： 8月初-8月末30t： 专业课： 7月初-7月末30t： 8月初-8月末30t： PAT: 7月初 - 8月末 政治 7月初 - 8月末 看张宇强化视频 ——做英——记录408电子版笔记——看政治强化视频 真题阶段：（9月）数学： 9月8-9月末22t： 专业课： 9月8-9月末22t： PAT： 9月1-9月末7t 政治 9月8-9月末22t 冲刺阶段（10-12月)数学 数学张宇六套卷 汤家凤七套卷 李永乐八套卷 李林六套卷 超越六套卷 闭关修炼错题 辅导讲义错题，1800错题 真题错题专题训练 + 01 - 10小题训练 难点重点复习 英语 真题 17- 19 全真模拟 10 - 15 研究题型， 作文准备 政治 肖八套选择 难点加强巩固1000题多选 408体系完善","categories":[],"tags":[]},{"title":"PAT","slug":"PAT","date":"2019-10-16T08:23:16.000Z","updated":"2020-10-06T15:23:38.781Z","comments":true,"path":"2019/10/16/PAT/","link":"","permalink":"http://example.com/2019/10/16/PAT/","excerpt":"","text":"1009多项式的乘法++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define NULL 0typedef struct PolyNode *Polynomial;int length = 0;struct PolyNode &#123; double coef; int expon; Polynomial link;&#125;;void Attach(double c, int e, Polynomial* pRear)&#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125;Polynomial ReadPoly (void)&#123; Polynomial P,Rear,t; int n; double c; int e; scanf(&quot;%d&quot;, &amp;n); P=(Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link=NULL; Rear=P; while(n--) &#123; scanf(&quot;%d %lf&quot;, &amp;e, &amp;c); Attach(c, e, &amp;Rear); &#125; t=P; P=P-&gt;link; free(t); return P;&#125;Polynomial Mult( Polynomial P1, Polynomial P2 )&#123; Polynomial P, Rear, t1, t2, t; double c; int e; if (!P1 || !P2) return NULL; t1 = P1; t2 = P2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while (t2) &#123; /* 先用P1的第1项乘以P2，得到P */ Attach(t1-&gt;coef*t2-&gt;coef, t1-&gt;expon+t2-&gt;expon, &amp;Rear); t2 = t2-&gt;link; &#125; t1 = t1-&gt;link; while (t1) &#123; t2 = P2; Rear = P; while (t2) &#123; e = t1-&gt;expon + t2-&gt;expon; c = t1-&gt;coef * t2-&gt;coef; while (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) Rear = Rear-&gt;link; if (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123; if (Rear-&gt;link-&gt;coef + c) Rear-&gt;link-&gt;coef += c; else &#123; t = Rear-&gt;link; Rear-&gt;link = t-&gt;link; free(t); &#125; &#125; else &#123; t = (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef = c; t-&gt;expon = e; t-&gt;link = Rear-&gt;link; Rear-&gt;link = t; Rear = Rear-&gt;link; &#125; t2 = t2-&gt;link; &#125; t1 = t1-&gt;link; &#125; t2 = P; P = P-&gt;link; free(t2); return P;&#125;void Pint(Polynomial P)&#123; int flag = 0; if (!P) &#123; printf(&quot;0 0\\n&quot;); return;&#125; while(P)&#123; if(!flag) flag = 1; else&#123; printf(&quot; &quot;); &#125; printf(&quot;%d %.1f&quot;, P-&gt;expon ,P-&gt;coef); P = P-&gt;link; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; Polynomial P1,P2,P; P1 = ReadPoly(); P2 = ReadPoly(); //Pint(P1); //Pint(P2); P = Mult(P1,P2); Pint(P); return 0;&#125; 1024科学计数法123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int main()&#123; char a[10010]; int i,j,k; int jie=0; gets(a); if(a[0] == &#x27;-&#x27;) printf(&quot;-&quot;); for(i = 1;a[i] != &#x27;E&#x27;; i++); for(j = i+2; a[j] != &#x27;\\0&#x27;; j++) jie=jie*10+a[j]-&#x27;0&#x27;; if(a[i+1] == &#x27;+&#x27;)&#123; for(j=1;j &lt; i; j++)&#123; if(a[j] == &#x27;.&#x27;) continue; printf(&quot;%c&quot;, a[j]); if(j == jie+2 &amp;&amp; jie &lt; i - 3 ) printf(&quot;.&quot;); &#125; if(jie &gt; i-3) for(j = 0; j &lt; jie-i+3;j++) printf(&quot;0&quot;); &#125; else&#123; printf(&quot;0.&quot;); for(j = 0; j &lt; jie-1; j++) printf(&quot;0&quot;); for(j=1;j&lt;i;j++)&#123; if(a[j] == &#x27;.&#x27;) continue; printf(&quot;%c&quot;, a[j]); &#125; &#125; return 0;&#125; 1048 数字加密本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式：输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式：在一行中输出加密后的结果。 输入样例：1234567 368782971输出样例：3695Q8118 自己的思路没有用到数组的反转，硬刚。错误点很多，耗时长 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int main()&#123; int temp,i,j,flag&#x3D;0, lengtha,lengthb,t; char a[250], b[252], c[3] &#x3D; &#123;&#39;J&#39;,&#39;Q&#39;,&#39;K&#39;&#125;, output[250]; scanf(&quot;%s&quot;, a); scanf(&quot;%s&quot;, b); lengtha &#x3D; strlen(a); lengthb &#x3D; strlen(b); if(lengtha &lt; lengthb)&#123; for(i &#x3D; lengtha - 1;i &gt;&#x3D; 0; i--) a[i+lengthb-lengtha] &#x3D; a[i]; t&#x3D;lengthb-1; for(i &#x3D; 0; i&lt;lengthb - lengtha;i++) a[i]&#x3D;&#39;0&#39;; &#125; else if(lengthb &lt; lengtha)&#123; for(i &#x3D; lengthb - 1;i &gt;&#x3D; 0; i--) b[i-lengthb+lengtha] &#x3D; b[i]; t&#x3D;lengtha-1; for(i &#x3D; 0; i&lt;lengtha - lengthb;i++) b[i]&#x3D;&#39;0&#39;; &#125; else t&#x3D;lengtha-1; for(i &#x3D; t;i &gt;&#x3D; 0;i--)&#123; if(!flag) flag&#x3D;1; else flag &#x3D; 0; if(flag)&#123; temp&#x3D;a[i] + b[i] - &#39;0&#39;-&#39;0&#39;; if(temp &lt; 10 || temp &gt;&#x3D; 13) output[i] &#x3D; temp % 13 + &#39;0&#39;; else output[i] &#x3D; c[temp - 10]; &#125; else&#123; output[i] &#x3D; (b[i] - a[i] + 10) % 10 +&#39;0&#39;; &#125; &#125; for(i&#x3D;0;i &lt; t+1;i++) printf(&quot;%c&quot;, output[i]);&#125; 答案12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn &#x3D; 110;char A[maxn], B[maxn], ans[maxn] &#x3D; &#123;0&#125;; void reversing(char s[]) &#123; int len &#x3D; strlen(s); for(int i &#x3D; 0; i &lt; len &#x2F; 2; i++) &#123; int temp &#x3D; s[i]; s[i] &#x3D; s[len - 1 - i]; s[len - 1 - i] &#x3D; temp; &#125;&#125; int main() &#123; scanf(&quot;%s %s&quot;, A, B); reversing(A); reversing(B); int lenA &#x3D; strlen(A); int lenB &#x3D; strlen(B); int len &#x3D; lenA &gt; lenB ? lenA : lenB; for(int i &#x3D; 0; i &lt; len; i++) &#123; int numA &#x3D; i &lt; lenA ? A[i] - &#39;0&#39; : 0; int numB &#x3D; i &lt; lenB ? B[i] - &#39;0&#39; ：0; if(i % 2 &#x3D;&#x3D; 0) &#123; int temp &#x3D; (numB + numA) % 13; if(temp &#x3D;&#x3D; 10) ans[i] &#x3D; &#39;J&#39;; else if(temp &#x3D;&#x3D; 11) ans[i] &#x3D; &#39;Q&#39;; else if(temp &#x3D;&#x3D; 12) ans[i] &#x3D; &#39;K&#39; else ans[i] &#x3D; temp + &#39;0&#39;; &#125; else&#123; int temp &#x3D; numB - numA; if(temp &lt; 0) temp +&#x3D; 10; ans[i] &#x3D; temp &#x3D; &#39;0&#39;; &#125; &#125; revers(ans); puts(ans); return 0;&#125; 1077 Kuchiguse （20 分)The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality: Itai nyan~ (It hurts, nyan~) Ninjin wa iyada nyan~ (I hate carrots, nyan~) Now given a few lines spoken by the same character, can you find her Kuchiguse? Input Specification:Each input file contains one test case. For each case, the first line is an integer N (2≤N≤100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive. Output Specification:For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write nai. Sample Input 1:3Itai nyan~Ninjin wa iyadanyan~uhhh nyan~Sample Output 1:nyan~Sample Input 2:3Itai!Ninjinnwaiyada T_TT_TSample Output 2:nai 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;string.h&gt;char a[10000][100000];int n;void traverse(char s[]) &#123; int temp; int len &#x3D; strlen(s); for(int i &#x3D; 0; i &lt; len&#x2F;2; i++)&#123; temp &#x3D; s[i]; s[i] &#x3D; s[len - i -1]; s[len - i - 1] &#x3D; temp; &#125;&#125;int min(int n) &#123; int min &#x3D; 1000; int temp; for(int i &#x3D; 0; i &lt; n; i++) &#123; temp &#x3D; strlen(a[i]); if(temp &lt; min) min &#x3D; temp; &#125; return min;&#125;int main()&#123; int flag,j,i; int minlen, same &#x3D; 0; scanf(&quot;%d&quot;, &amp;n); if(n &#x3D;&#x3D; 0) &#123; printf(&quot;nai&quot;); return 0;&#125; getchar(); for(i &#x3D; 0; i &lt; n; i++) &#123; gets(a[i]); &#x2F;&#x2F;printf(&quot;%dfjakfa0\\n&quot;, i); traverse(a[i]); &#x2F;&#x2F;puts(a[i]); &#125; &#x2F;&#x2F;while(1); minlen &#x3D; min(n); for(i &#x3D; 0; i &lt; minlen; i++) &#123; flag &#x3D; 0; char c &#x3D; a[0][i]; for(j &#x3D; 0; j &lt; n; j++) &#123; if(c !&#x3D; a[j][i])&#123; flag &#x3D; 1; break;&#125; &#125; if(!flag) same &#x3D; i+1; else break;&#x2F;&#x2F;这句话没加，导致查第三个点查了好久！！！（如果没加，后面又有都相等的就覆盖掉了） &#125; if(same &#x3D;&#x3D; 0)&#123; printf(&quot;nai&quot;); return 0; &#125; for(i &#x3D; same; i &gt; 0; i--)&#123; printf(&quot;%c&quot;, a[0][i-1]); &#125;&#125; 1082 Read Number in Chinese （25 分)Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai. Input Specification:Each input file contains one test case, which gives an integer with no more than 9 digits. Output Specification:For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 1:-123456789 Sample Output 1:Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 2:100800 Sample Output 2:yi Shi Wan ling ba Bai 自己的思路：整体上是一个数字（traverse）后跟着一个位（chinese）但要处理以下特殊情况1.负数2.末尾的处理 2.1 普通末尾2.2 末尾为零 3.零的处理 这样的思路还是枚举法，很容易少考虑到一些情况，如果实战真用这种法方，那心态估计早就崩了吧。。。。。。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char a[11]; char traverse[10][10] &#x3D; &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;&#125;; char chinese[10][10] &#x3D; &#123;&quot;Yi&quot;, &quot;Qian&quot;, &quot;Bai&quot;, &quot;Shi&quot;, &quot;Wan&quot;, &quot;Qian&quot;, &quot;Bai&quot;, &quot;Shi&quot;&#125;; int i,j,k,n; int lastone; int specialflag &#x3D; 0; scanf(&quot;%s&quot;,a); n &#x3D; strlen(a); if(a[0] &#x3D;&#x3D; &#39;-&#39;) &#123; printf(&quot;Fu &quot;); i &#x3D; 1; &#125; else i &#x3D; 0; if(n &gt;&#x3D; 9 )&#123; for(k &#x3D; i + 1, j &#x3D; k+4; k &lt; j; k++) if(a[k] !&#x3D; &#39;0&#39;) break; else specialflag ++; &#125; lastone &#x3D; n-1; while(a[lastone] &#x3D;&#x3D; &#39;0&#39;)&#123;lastone--;&#125; while(a[i] &#x3D;&#x3D; &#39;0&#39;) i++; for(; i &lt; n - 1; i++) &#123; if(a[i] !&#x3D; &#39;0&#39; || (a[i + 1] !&#x3D; &#39;0&#39; &amp;&amp; a[i] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; i &lt; n - 1 &amp;&amp; strcmp(chinese[i + 9 - n] , &quot;Wan&quot;) !&#x3D; 0)) printf(&quot;%s &quot;, traverse[a[i] - &#39;0&#39;]); &#x2F;&#x2F; &#123; printf(&quot;ling &quot;); continue;&#125; if(((a[i] !&#x3D; &#39;0&#39;)||(a[i] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; strcmp(chinese[i + 9 - n] , &quot;Wan&quot;) &#x3D;&#x3D; 0 &amp;&amp; specialflag !&#x3D; 4 )))&#123; if(i &lt; lastone ) printf(&quot;%s &quot;, chinese[i + 9 - n]); else &#123; if(i + 9 - n &lt; 4 &amp;&amp; specialflag !&#x3D; 4) printf(&quot;%s &quot;, chinese[i + 9 - n]); else printf(&quot;%s&quot;, chinese[i + 9 - n]); &#125; &#125; &#125; if(a[i] !&#x3D; &#39;0&#39;) printf(&quot;%s&quot;, traverse[a[i] - &#39;0&#39;]); &#x2F;&#x2F;printf(&quot;ajdkfl&quot;);&#125; 未完 测试点三一直没过 感觉就像熟悉的大二freescale式的if else 代码 好吧解决掉了，忘记处理单零的情况，哭晕在厕所。。。。。。。","categories":[],"tags":[]},{"title":"NXP","slug":"nxp","date":"2018-09-06T07:10:16.000Z","updated":"2020-10-06T15:11:23.881Z","comments":true,"path":"2018/09/06/nxp/","link":"","permalink":"http://example.com/2018/09/06/nxp/","excerpt":"","text":"2018年度总结札记可能是第一次认真的在年末写这种东西，之前不想写的原因是总结是随时随地的，不应该都挤在年末的时候。然而今年想写的原因一个是因为这个网站吧，另一个便是感觉自己好像真的认清自己了，认清了这个不敢直视的自己。 流水线2018.1.1-2018-7.26这段时间正是准备省赛的是侯，当时的想法已经在之前记录过： ——这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。 记得第一次偷偷地在浙大智能车培训ppt上看到这句话的时候，不解为何要单独摘出这句话。如今一切既定，虽然不想承认，但恍惚发现这碗毒鸡汤正是准备给自己。 智能车，与其说他是一门竞赛，倒不如说是一种生活。第一次接触它的时候，是在去年盛夏的一个傍晚。看到儿时四驱兄弟的现场真人版，不自觉地浮想联翩。但开始经历暑期培训之后，才知这生活并不好受。一来便发现自己与其他同学水平之间的差距大到无法与他们交流，当我的呼吸灯还没正常闪烁时他们已经能用链表玩起了贪吃蛇，当我还在研究怎么让数据传回电脑时，他们已经调稳了传回的波形甚至加了我至今不明原理的滤波。几度想过放弃但所幸有学长一旁鼓励 。 半坚持半发呆地熬过了任务最繁杂的时期。晚上放松时，在寝室偷偷地刷完了《鸡毛飞上天》。大二上学期，记得是最燃的一个学期。那时一直都很幸运，因为付出的汗水都得到了回报。C+的图像一遍一遍的改，速度也会一点一点的提升，有好几次在凌晨对望六教五楼的考研教室，知道熬夜不好，但那时内心还是很开心入梦时耳边是《火影忍者》的主题曲。 寒假的时候，脑子里还在想着如何用好编码器再提点速，却被告知更换了组别。当时内心并不想调直立，因为真的只是单纯觉得四个轮子更帅些，更像儿时的四驱兄弟。不过被换到的是当时我们觉得最好的组别，战斗力不减反增。延续着上学期良好的状态，充实的过活（不过可能是假期的原因，竟刷完了高圆圆的几乎所有的影视剧）可能是寒假用力过猛，大二下学期的开学丝毫没有仪式感。利用前俩个星期选课时间在寝室咸鱼。因白天不用调车，甚至觉得着生活比寒假都要轻松。温水在逐渐变烫，我这只青蛙也觉得压力慢慢变大。电磁的直立并不像摄像头的C+那样方法相对固定而又唯一，为了上速可以采取多种多样的方式：更改机械、改变电感的排布方案和算法、速度开环与闭环的选择、分段、模糊、串级、优化路径。没有人告诉你哪个是主要矛盾，哪条路好走，也没有人告诉你哪个方案到什么程度便该放弃。所以说下学期的路走的特别艰辛：一会儿找着串级大神聊天请教，一会儿发誓用一个星期亲手建个模糊表，一会儿又频繁刷着论坛看中南大佬如何调路径，因自身学习能力的欠缺和时间的限制我经历数次尝试，失败，再次尝试，再次失败，几度体验到绝望，几度在黑夜中啜泣。（那时候的晚上最喜欢明星是何炅，最喜欢看的综艺是《向往的生活》，最喜欢听的歌是金玟岐的姗姗）在上述这些都没搞通的同时，特殊元素的出现又让我们煞费苦心。校赛结束之后从弯入环岛开始，这个或大或小的圈便成了我们生活的重头戏：秉承着一次性搞完美的原则，起步便想拟合完美的路迹。当发现这种方法太过困难时，成功的在环上栽了第一个跟头。而后选择了做小改动然后不断优化，成功解决了弯接问题但成功率不高，它的简陋像定时炸弹一样埋在心底，让人总不心安。 16周结束，期末考试如期而至。这个学期有太多次惯性地通过在宿舍发呆来治愈方案频繁更换所带来的挫败感，做功课的时间寥寥无几，所以考试周的时候十分疲惫却又不得好处。熬完四门主要考试后就到了真正的冲刺阶段。10天的时间，来不及调整作息，从一整夜到18小时再到24小时，那段时间真的怀疑有失眠症这种东西,还以为亲身经历了马尔克斯的魔幻现实世界。现在想来，其实只是不甘罢。为了最后提速而加了速度环之后，之前的定时炸终于引爆。慌乱之中我们又尝试了全新的电感架法，不幸的是照搬效果欠佳。无奈帅锅硬件，宣布第三次改环以失败告终。这时已离封车不到一周，一次又一次的失败使我们乱了阵脚，所幸一年的历练让我们韧性大增，在可能的情况下尽着自己最大的努力。第三次环岛失败之后，我们回归原始摒弃各种束缚，去掉速度环，并将假闭环改为开环（虽说当时乱了阵脚后不易做大改动，但这痛定思痛后的决定在我现在开来还讲得通）。最后的效果如何我们并不清楚，因为已经没有时间再去尝试，因调试环岛而耽误了搓衣板，最后比赛只能放慢速。所幸最后一切顺利，结果均在预料之中，也算对这一年有一个交代。在智能车的这段日子里，流言蜚语不断，以致使我质疑加入这撸猫大队是否是个明智的选择。但一年完整经历下来（并不），自己认为十分值得。除了学习了一定控制领域的知识，更多的是明白了一些惯习的魅力：螺丝松了立马拧紧，温柔接车，下意识避开赛道，备份代码备份心情……还发现了自己所欠缺的：善良，合作，选择时的慎重，对自己该何时严格何时宽恕。 要克制自怜，更要将因抉择失误而产生的自悯，情绪尽量降低，唯有时刻保持清醒，才能看清真正的价值在哪里。 2018.7.26-2018.8.26在家中的这段时间得到了一定的放松，在世俗的生活里似乎也慢慢忘记了上个月的伤痛。时间永远是抚平伤痛最好的良药。见了几个挚友，回了一次老家，尝试了几次尽情的咸鱼，发现慢慢可以放下过去，继续往前行了，于是买了那本现在还在复习的单词书，当时每天早上都有在认真的背，怎奈事情繁多，时间太紧，还没背几个list就面临开学了。现在回想，这段时间里并没有给我带来什么，当时的想法也是把这段时间当作稍作歇息把，毕竟觉得人不可能永远紧绷着，需要一段时间停下了去看看过去的时光。 2018.8.26-2018.11.24作为这个学期的前半段阶段，诚然还是过的挺有规律的，虽然有些时候会做出一些令自己后悔的选择，但是总体来说，选择了考英语，选择了考研，选择了学校。有规律也有对自己的一定程度上的自信。但是当时有一件事情感觉对自己有一定影响的是去参加的物理竞赛吧。当时发现自己的一个特点，对不上心的东西做的并不是特别认真，一开始的时候，想通过一个简单的32机器人去检测自己一年所学的知识到了什么程度，但是做到一半发现自己心态开始转变，觉得这件事情很难通过一个人的力量来做到我想做的程度，并且认为这件事情也不是在我计划中最为关键的事情，于是慢慢放手，不再花太多经历在上面不打算花太多经历在上面，于是便有了之后的结果。 2018.11.24-2018.12.30这段时间里面，对自己的怀疑开始达到了顶峰，随着考试时间的逐渐接近，发现自己所学的东西并没有像之前自己想象的那么多。开始怀疑自己是否能够平衡英语的学习和专业课的学习，也开始怀疑自己是否有能力去考取高一时便订下机缘的大学。这段时间里面也努力渴求能找到一些东西把我从自我怀疑、自我贬低的深渊中拉出来。看过一个泪流满面的电影《无问西东》。“这个是世界缺的不是完美的人，而是从心底给出真心、正义、无畏与同情”。这句话让我产生了一定的勇气，只身一人去找了自己的两位导师。想要通过他们的帮助让自己走出泥淖。他们所给的建议便是自己给自己卸掉一定的压力，当然这和他们所处的年龄以及对我了解程度有一定的关系，不能全盘的吸收，还是要辨证的去看待他们所给的建议。所以说让我成为现在自己的原因，是这自己肩上的担子吗？ 我觉得并不是，我觉的最重要的是对自己的真实。“世俗这样强大，强大到生不出改变他们的念头来。可是无论外界的社会如何跌宕起伏，都对自己真诚，坚守原则，内心没了杂念和疑问，才能勇往直前”什么是对自己的真实？对自己的真实是指能认清真正值得自己。因为木心的“论事无涉私心意气谓之谦，命世不计个人得失谓之狂”而人有内心的膨胀和现实的自我贬低是不真实，看到身边的朋友活出了自己想要的模样而过分倾羡也是不真实，一口气拦下很多任务定出过高的目标也是不真实，总之，越是对自己不真实，就越容易陷入自我怀疑的泥淖。然而问题来了，基于现在的情况，我应该如何才能逐渐做到对接越来越真实呢？","categories":[],"tags":[{"name":"Study","slug":"Study","permalink":"http://example.com/tags/Study/"}]}],"categories":[],"tags":[{"name":"Study","slug":"Study","permalink":"http://example.com/tags/Study/"}]}