{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Neoth","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2020-10-06T13:34:41.000Z","updated":"2020-10-06T13:34:41.665Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-06T13:36:30.000Z","updated":"2020-10-06T13:36:30.492Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-06T13:36:19.000Z","updated":"2020-10-06T13:36:19.880Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"newth","slug":"newth","date":"2020-10-08T06:02:39.000Z","updated":"2020-10-09T05:30:43.299Z","comments":true,"path":"2020/10/08/newth/","link":"","permalink":"http://example.com/2020/10/08/newth/","excerpt":"","text":"项目介绍第二次一个人来到南京，对这个城市的感觉一直不错，这次下了火车依旧有着这样的感觉，当然除了人多：十月一假期，夫子庙旁人是真滴多，第一次感受到身为行人也会被堵住的感觉，周围大家的脚步都是极缓，漫步在南京街头目光聚焦在一个个新奇有特色的的小店，然而我缺恨不得一步化作两步，眼神死死地锁在百度地图上，担心着第一次见面就会迟到。所幸最后赶到青旅的时候刚刚到时间，来不及换衣服直接偷偷的滑进座位中。台上组委在讲着项目的ppt，下面我们就在默默的讨论起谁是谁，三天的时间太短，若不刻意记一下名字，时间可能趁我们不注意就摘走几个人的缘分呢。自我介绍完了开始了游戏互动和才艺展示的环节，印象最深的便是YG的差不多先生，唱的很有感觉，一看就是一个老歌唱艺术家了，然而事后才知道这位兄弟才17，年都没成，大他半轮的我真的是无地自容。。。罢了，别和往事战斗我们不是对手，到我们组的时候就有点尴尬，大家好像都没准备啥才艺展示,最后还是组长LX出来担当，心理学小知识也是挺有意思的。 事罢，分组行动。我们一组来到了河边品起了茶，听起了CLG在拉萨的旅行，布达拉宫的故事很动人，真心让人按捺不住想去的心情。从上海开始一个人坐着Z164一路穿过腹地到拉萨，到布达拉宫-大昭寺 纳木错 日喀则 帕里草原 珠峰 嘉措拉山 三圣石去体验高处圣洁的美，说多了真的有点忍不住启程了，如果有想去的小伙伴可约哦，也支持自驾。之后大家也讨论了一下自己想到的有关零元生存的方法，当时的我还沉浸在斯皮尔伯格的《逍遥法外》里，以为生存会是一件相当简单的事情，现在想起来确实有些可笑。此外文艺的WYQ分享了一部纪录片——《世界上的另一个我》，一个找寻与主人公同一天生日的故事，真心推荐，90后妈妈不知为何戳到泪点了，整一集都是哭下来的。 破冰活动翌日八点，广场破冰。项目：叼水接龙 背靠起身 站报纸 随意倒下。本以为身为极挑的忠实粉丝，对这些有些应该手到擒来，然而结果不是太如意，一群人站在一张报纸上有些难度。不过头一次与陌生的朋友玩这些活动感觉还是很开心。ps：活闹鬼（小混混）画的很棒。 挑战者行动下午大家开始做起了对方组给留下的任务，以及组委给的场地寻找。本来打算发一波力，看大家都边逛边玩，就佛了一把。不过瞻园寻找平靖王谕寻找的实在是没有章法，自己走了好多回头路，这空间记忆能力还是要刻意加强一下。 百里夜行夜走玄武湖，一个好友用来思考人生的地方。之前白天来的时候就想在这边拍张南京的夜景，这次也算是完成了未了的心愿，自然是比较开心。而且大家一路走，一路笑，一路欢歌，一路拍照真的很有感觉。尝试了解了几位朋友，尝试拍了下大光圈夜景，兴致正勃，一场雨按下了结束键。大家被逼无奈，改到海底捞去继续嗨。怎奈空间有限，没有觅食的欲望，便和海底捞师傅学起了扯面。y1s1,扯面没有看起来那么简单。 回去路上LX曾问过我对计算机是否真心热爱，这个问题回去想了好久，要是放在四年之前我想我的回答必是肯定的，但如今经历了四年的学习和尝试，总觉得其实际情况与之前所想有所差距。当时一直认为，计算机学科作为最新型的朝阳行业，是所有风口的集合，其本质就是快速的迭代和不断的学习。通过学习计算机不光是掌握一门谋生的手艺，更重要的是打通底部内核的学习能力。这一点从这个行业的就业情况便能看出，除计算机行业以外，其他行业的工资相对来说都会偏低，原因是实际工业界并不认可大学生在校所学的知识，招聘的原则只是通过学历、沟通、综合素质等硬性指标评判其是否有值得被培养的潜力。然而IT行业的同学可以通过很简短的培训直接上手公司里的实际项目，其自学能力是通过接触各种各样的复杂环境配置，各个方向的新兴领域，一点点培养起来的。然而放到现在，我又很难像四年前那样给出如此肯定的答案。不知什么时候，自己因为算法工程师的oc太少，从而不愿接触AI领域的知识；不知什么时候不愿学习与自己技术栈里没有的课程，也不知道什么时候就真把计算机当做了一门谋生的手艺。也许是看到实际工厂搬砖中螺丝钉的渺小吧，也许是看到身边一个个火热的灵魂选择了更为稳妥的选调吧。社会慢慢得把这门行业贴上了“高薪”“996”“青春饭”这些标签，这些标签潜移默化的影响着年轻人对这个行业的态度，外加日严重的生存压力，太多的人失去了当年的热枕，太多的人抱怨无法做到work—life balance。所幸我想起了我们都经历过高考，并不是因为他有多苦(和现在相比不值一提)，而是因为他push着你做一些无聊、单调、缺乏反馈机制的活动，而经历过这些后我们依然能对其保持着一定的兴趣，这是一笔十分宝贵的财富，这是在当今压力爆棚的社会生存的秘密武器，真的感谢山东省这看似欠发达却又很接地气的教育体制。回到是否真心热爱计算机这个问题上，现在我只能回答我不知道，越长大越发现世界上罕有0和1的答案，我只能说现在还不太讨厌，未来会不会越来越喜欢，这又有谁说的准呢？ 零元生存开始的开始，我们都没票子。最后的最后，渴望再来一次。 一群人，几张明信片，几把躲雨的伞，几部记录生活的相机就开始了我们没钱没手机的流浪一天，开始时大家一同前往小商品市场，打算进点货，赊点账。但老板都是生意人，没有遇到肯赊给我们货的天使。于是两组分头而去，我们选择先去解决货币流通问题，找南京唯一熟悉我们的店家——青旅老板打印了几张二维码，便开始了苟活的旅途。上午我们在夫子庙附近，先是以卖报，啊呸，卖抱为生。后来又辅之以卖明信片，过活的还不错。遇到了很多好心的小哥哥，小姐姐，还有一对来自英格兰和南美的情侣，总共赚了五六十，每个人吃了块硬核的大饼当做中饭，真的是一点渣都不敢掉，那心情很难用文字形容。我们拿着早上的成果，回到小市场去进货，买了些许的雨衣和头巾。开始两两一组的小贩生活，两位女生卖头巾，大哥和MC卖雨衣，我和摄影师继续用明信片讨生活。 于是下午便和CLG一起去了先锋书店开启了我们的情怀之旅，可能是因为我们没有剥去社会对年轻人的宠爱吧（披着挑战者活动的外衣），并没有太多的碰壁，几乎很少会有人拒绝给我们写明信片的请求。问题只出在我们的的策略之上：在好不容易与陌生人简历了彼此信任的基础上没能将其平滑的过渡到利益关系，也就是我们让陌生人免费写完卡片后，没有过渡到让着他们支付费用带走卡片，从而导致最后我们没有新的卡片给陌生人写，很难再跟陌生人建立最初的信任了。不过下午的重点还在在于和CLG学习拍摄的技术，了解了一些和陌生人拍照的方法，懂得了镜头是一种比较带有攻击性的语言。让自己对拍照这件事请有了新的理解。 人文扫街，感觉是一种比较奇特的交流方式，他打破了国内陌生人之间比较冷淡的意识形态，试图用一种攻击性较强的语言去寻找一种新的沟通途径，这种途径可以较为快速的让两个陌生人之间产生链接。当然既然是一种新的，不被正常人所接受的方式，其实践的过程中肯定是痛苦的，可以想而知必定充斥着拒绝。然而要知道一切的重构都伴随着极为强烈的痛苦，但这种痛苦是有意义的，就像Jiang Jia的rejection therapy。受其影响，特别想记录一下自己扫街约陌生人的过程，估计肯定会是一件很有意思的事情。 晚上两组在青旅会面，交流着白天自己组的经历，各不相同，都很精彩。接下来我们便在青旅等待着KTV开始，也就是在这个时候龙总和罗总的年度大戏正式上映，真的有被笑道，很精彩的两位演员！也就是这个时候和同在青旅住宿的两个朋友聊了起来，看到了他们身为毕业后的社会人的辛酸，也让我更加清晰地了解到应届生的身份真的是太太太太太宝贵了，社招和校招真就天差地别。 夜晚一群人零点左右奔向KTV,也算是城市一道亮丽风景线。GWL和LSY两人为我们一行人复出了很多，用脚力在我们前面跑着做起了BFS广搜，在无导航的黑夜里做起了我们的明灯。到了KTV后遇到了人很nice的前台小姐姐，白天在医院当护士，晚上出来兼职，呵，生活。KTV的包间很震撼，真没想到160多的包间会有如此规格，一行人在歌厅中嗨到了半夜。 活动收尾零元生存结束，我们拿到了自己的手机，然而再次拿起他的时候，我们变了，变的不会因他的消失而惊慌失措，变得有信心在没终端的世界流浪。经历这次活动，真的很开心。然而，至于我自己，拿到手机的时候发现他裂了。透，第一天晚上摔了一下，一开始只以为膜碎了，结果是屏碎了。难道是发现了我能离开它后作出的无声的抗议？由于国庆假期后续排的有些满，没法单独找时间去修，只能独自脱离队伍在南京开始寻找菊厂维修店之旅，倒也是应了我这不合群的性格，但没能和大伙一起享用最后一顿午餐还是相当的遗憾。 中午时分，大家又一起回到了青旅，各自说了一下对这几天的感受。很奇妙，也很有开心。大学期间总是因为这事那事，没能赶上newth的活动，不然很多假期会变得更有意义，说了很多，也还有很多没说。However, To put it into a nutshell , we made the burger refill.","categories":[],"tags":[]},{"title":"DS-D","slug":"pat模拟拟","date":"2020-07-06T15:45:01.000Z","updated":"2020-10-08T14:44:05.384Z","comments":true,"path":"2020/07/06/pat模拟拟/","link":"","permalink":"http://example.com/2020/07/06/pat%E6%A8%A1%E6%8B%9F%E6%8B%9F/","excerpt":"","text":"06-图2 Saving James Bond - Easy Version (25 分)This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape. Input Specification:Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position. Output Specification:For each test case, print in a line “Yes” if James can escape, or “No” if not. Sample Input 1:14 2025 -15-25 288 4929 15-35 -25 2827 -29-8 -28-20 -35-25 -20-13 29-30 15-35 4012 12 Sample Output 1:Yes Sample Input 2:4 13-12 1212 12-12 -1212 -12 Sample Output 2:No Note 最小跳，人工乱序这个点过不了 过了， &gt;= 搞成了 &gt; 查了两晚上，终于查出来了。。。。 注意图的抽象概念，利用结构体存储也是可以的。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;#define MAX 10010struct crocodile&#123; int x; int y;&#125;crocs[MAX];int dis, num;int safe &#x3D; 0;int visited[MAX] &#x3D; &#123;0&#125;;bool Distance(int i, int j) &#123; if(i &#x3D;&#x3D; 0) &#123; if(pow(abs(0 - crocs[j].x) , 2) + pow(abs(0 - crocs[j].y) , 2) &gt; pow(dis + 7.5, 2)) return 0; else return 1; &#125; else &#123; if(pow(abs(crocs[i].x - crocs[j].x) , 2) + pow(abs(crocs[i].y - crocs[j].y) , 2) &gt; pow(dis, 2)) return 0; else return 1; &#125;&#125;bool IsSafe(int i) &#123; if(crocs[i].x &gt; 50 - dis || crocs[i].x &lt; dis - 50 || crocs[i].y &gt; 50 - dis || crocs[i].y &lt; dis -50) return 1; else return 0;&#125;void Dfs(int i)&#123; if(IsSafe(i) &amp;&amp; safe &#x3D;&#x3D; 0)&#123; cout &lt;&lt; &quot;Yes&quot;; safe &#x3D; 1; &#125; else &#123; for(int j &#x3D; 1 ; j &lt;&#x3D; num; j++) &#123; if(Distance(i, j) &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)&#123; visited[j] &#x3D; 1; Dfs(j); &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; num &gt;&gt; dis; crocs[0].x &#x3D; crocs[0].y &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; num; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; crocs[i].x &#x3D; a; crocs[i].y &#x3D; b; &#125; for(int i &#x3D; 1; i &lt;&#x3D; num; i++) &#123; if(Distance(0, i) &#x3D;&#x3D; 1 &amp;&amp; visited[i] &#x3D;&#x3D; 0)&#123; visited[i] &#x3D; 1; Dfs(i); &#125; &#125; if(!safe) cout &lt;&lt; &quot;No&quot;; return 0;&#125; 06-图3 六度空间 (30 分)“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。 图1 六度空间示意图“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。 假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。 输入格式:输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤10^4​ ，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。 输出格式:对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。 输入样例:10 91 22 33 44 55 66 77 88 99 10 输出样例:1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00% Note 利用邻接表存储 利用last tail算层数 有两个点还是过不了， 每日之邪 改进终于过了，原因是类型转换，算完之后再转double肯定小数点后面都是零哇。。Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;using namespace std;#define MAXN 11000#define MAXA 50struct EdgeNode&#123; int data; EdgeNode *next;&#125;;struct Vnode&#123; EdgeNode *FirstEdge;&#125;;Vnode V[MAXN];int NodeNum, ArcNum;void Create(Vnode V[])&#123; cin &gt;&gt; NodeNum &gt;&gt; ArcNum; for(int i &#x3D; 0; i &lt; NodeNum; i++)&#123; V[i].FirstEdge &#x3D; NULL; &#125; for(int i &#x3D; 0; i &lt; ArcNum; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; EdgeNode *edge; edge &#x3D; (EdgeNode*)malloc(sizeof(EdgeNode)); edge-&gt;data &#x3D; b; edge-&gt;next &#x3D; V[a - 1].FirstEdge; V[a - 1].FirstEdge &#x3D; edge; edge &#x3D; (EdgeNode*)malloc(sizeof(EdgeNode)); edge-&gt;data &#x3D; a; edge-&gt;next &#x3D; V[b - 1].FirstEdge; V[b - 1].FirstEdge &#x3D; edge; &#125;&#125;int SixDegreeBfs(int i) &#123;&#x2F;&#x2F;i是下标 queue&lt;int&gt; q; int count &#x3D; 1, level &#x3D; 0, last &#x3D; i, tail &#x3D; 0; int visited[MAXN] &#x3D; &#123;0&#125;; visited[i] &#x3D; 1; &#x2F;&#x2F; visited中存下标 q.push(i); while(q.size() &gt; 0)&#123; int temp &#x3D; q.front(); q.pop(); EdgeNode *p &#x3D; V[temp].FirstEdge; for(; p !&#x3D; NULL; p &#x3D; p-&gt;next)&#123; if(visited[p-&gt;data - 1] &#x3D;&#x3D; 0)&#123; visited[p-&gt;data - 1] &#x3D; 1; q.push(p-&gt;data - 1); tail &#x3D; p-&gt;data - 1; count++; &#125; &#125; if(temp &#x3D;&#x3D; last)&#123; last &#x3D; tail; level++; &#125; if(level &#x3D;&#x3D; 6) break; &#125; return count; &#125;int main()&#123; Create(V); for(int i &#x3D; 0; i &lt; NodeNum; i++)&#123; int temp &#x3D; SixDegreeBfs(i); printf(&quot;%d: %.2f&quot;, i+1, (double)(temp*1.0*100&#x2F;NodeNum)); cout &lt;&lt; &quot;%&quot;; printf(&quot;\\n&quot;, temp); &#125; return 0;&#125; 07-图4 哈利·波特的考试 (25 分)哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。 现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。 输入格式:输入说明：输入第1行给出两个正整数N (≤100)和M，其中N是考试涉及的动物总数，M是用于直接变形的魔咒条数。为简单起见，我们将动物按1~N编号。随后M行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。 输出格式:输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。 输入样例:6 113 4 701 2 15 4 502 6 505 6 601 3 704 6 603 6 805 1 1002 4 605 2 80输出样例:4 70 Note 利用floyd求出两点之间的最短路长度 找到每行中最大的，比较哪一行最大的更小 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;#define MAX 1000int a[MAX][MAX];int main()&#123; int num, arc; cin &gt;&gt; num &gt;&gt; arc; int i, j, k; for(i &#x3D; 0; i &lt; num; i++)&#123; &#x2F;&#x2F;初始化 for(j &#x3D; 0; j &lt; num; j++)&#123; a[i][j] &#x3D; MAX; &#125; &#125; for(i &#x3D; 0; i &lt; arc; i++)&#123; &#x2F;&#x2F;输入 int tempa, tempb, data; cin &gt;&gt; tempa &gt;&gt; tempb&gt;&gt; data; a[tempa - 1][tempb - 1] &#x3D; a[tempb -1][tempa - 1] &#x3D; data; &#125; for(k &#x3D; 0; k &lt; num; k++)&#123; &#x2F;&#x2F;floyd for(i &#x3D; 0; i &lt; num; i++)&#123; for(j &#x3D; 0; j &lt; num; j++)&#123; if(a[i][k] + a[k][j] &lt; a[i][j])&#123; a[i][j] &#x3D; a[i][k] + a[k][j]; &#125; &#125; &#125; &#125; int minall &#x3D; MAX, maxpart, temp1, temp2 &#x3D; MAX; for(i &#x3D; 0; i &lt; num; i++)&#123; &#x2F;&#x2F;找大中最小 maxpart &#x3D; 0; for(j &#x3D; 0; j &lt; num; j++)&#123; if(a[i][j] &gt; maxpart &amp;&amp; i !&#x3D; j)&#123; maxpart &#x3D; a[i][j]; &#125; &#125; if(maxpart &lt; minall)&#123; temp1 &#x3D; i + 1; temp2 &#x3D; maxpart; minall &#x3D; maxpart; &#125; &#125; if(temp2 &lt; MAX) cout &lt;&lt; temp1 &lt;&lt; &quot; &quot; &lt;&lt; temp2; else cout &lt;&lt; 0; return 0;&#125; Summary Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法 07-图5 Saving James Bond - Hard Version (30 分)This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make. Input Specification:Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position. Output Specification:For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique. Sample Input 1:17 1510 -2110 21-40 1030 -5020 4035 100 -10-25 2240 -40-30 30-10 220 1125 2125 1010 1010 35-30 10 Sample Output 1:40 1110 2110 35 Sample Input 2:4 13-12 1212 12-12 -1212 -12 Sample Output 2:0 Note 题目要求求经过的节点个数最小，BFS自带这种属性 利用path保存路径，图中遍历常用Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;#define MAX 10010int dis, num;int safe &#x3D; 0;int visited[MAX] &#x3D; &#123;0&#125;;struct Crocodile&#123; int x; int y;&#125;crocs[MAX];bool Distance(int i, int j) &#123; if(i &#x3D;&#x3D; 0) &#123; if(pow(abs(0 - crocs[j].x) , 2) + pow(abs(0 - crocs[j].y) , 2) &gt; pow(dis + 7.5, 2)) return 0; else return 1; &#125; else &#123; if(pow(abs(crocs[i].x - crocs[j].x) , 2) + pow(abs(crocs[i].y - crocs[j].y) , 2) &gt; pow(dis, 2)) return 0; else return 1; &#125;&#125;bool cmp(int i, int j)&#123; if (pow(abs(0 - crocs[i].x) , 2) + pow(abs(0 - crocs[i].y) , 2) &lt; pow(abs(0 - crocs[j].x) , 2) + pow(abs(0 - crocs[j].y) , 2) ) return 1; else return 0;&#125;bool IsSafe(int i) &#123; if(crocs[i].x &gt;&#x3D; 50 - dis || crocs[i].x &lt;&#x3D; dis - 50 || crocs[i].y &gt;&#x3D; 50 - dis || crocs[i].y &lt;&#x3D; dis -50) return 1; else return 0;&#125;int main() &#123; cin &gt;&gt; num &gt;&gt; dis; if(dis &gt;42)&#123; cout &lt;&lt; 1; return 0; &#125; &#x2F;&#x2F;一步上岸 crocs[0].x &#x3D; crocs[0].y &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; num; i++) &#123; cin &gt;&gt; crocs[i].x &gt;&gt; crocs[i].y; &#125; vector&lt;int&gt; first(num + 1 ); &#x2F;&#x2F;准备重新排序 for(int i &#x3D; 0; i &lt; num + 1; i++)&#123; first[i] &#x3D; i; &#125; sort(first.begin(), first.end(), cmp); vector&lt;int&gt; path(num + 1, -1); &#x2F;&#x2F;待深度遍历的路径 queue&lt;int&gt; q; &#x2F;&#x2F;BFS int flag &#x3D; 0; int ptr &#x3D; -1; for(int i &#x3D; 1; i &lt;&#x3D; num; i++) &#123; if(Distance(0, first[i]) &#x3D;&#x3D; 1 &amp;&amp; visited[first[i]] &#x3D;&#x3D; 0)&#123; visited[first[i]] &#x3D; 1; q.push(first[i]); path[first[i]] &#x3D; 0; if(IsSafe(first[i])) &#123; flag &#x3D; 1; ptr &#x3D; first[i]; break;&#125; &#125; &#125; while(q.size() &gt; 0 &amp;&amp; flag &#x3D;&#x3D; 0)&#123; int temp &#x3D; q.front(); q.pop(); for(int i &#x3D; 0; i &lt; num; i++)&#123; if(visited[i] &#x3D;&#x3D; 0 &amp;&amp; Distance(temp, i))&#123; q.push(i); visited[i] &#x3D; 1; path[i] &#x3D; temp; if(IsSafe(i))&#123; flag &#x3D; 1; ptr &#x3D; i; break;&#125; &#125; &#125; &#125; if(flag &#x3D;&#x3D; 1)&#123; int temp[MAX]; int cnt &#x3D; 0; while(path[ptr] &gt; 0)&#123; temp[cnt++] &#x3D; ptr; ptr &#x3D; path[ptr]; &#125; cout &lt;&lt; cnt + 2 &lt;&lt; endl; cout &lt;&lt; crocs[ptr].x &lt;&lt; &quot; &quot; &lt;&lt; crocs[ptr].y &lt;&lt;endl; for(int i &#x3D; cnt -1; i &gt;&#x3D; 0; i--)&#123; cout &lt;&lt; crocs[temp[i]].x &lt;&lt; &quot; &quot; &lt;&lt; crocs[temp[i]].y &lt;&lt;endl; &#125; &#125; else if(!flag) cout &lt;&lt; 0; return 0;&#125;","categories":[],"tags":[]},{"title":"西北大环","slug":"西北大环","date":"2020-06-26T15:45:14.000Z","updated":"2020-10-09T05:26:13.593Z","comments":true,"path":"2020/06/26/西北大环/","link":"","permalink":"http://example.com/2020/06/26/%E8%A5%BF%E5%8C%97%E5%A4%A7%E7%8E%AF/","excerpt":"","text":"西北大环 Day1疫情期间，能有这次机会出来旅行真的实属不易，请假的理由真的是想了半个多月，伙同家长一起跟老师打迷踪拳。不过出了门还是格外的小心，在飞机上的口罩就没摘下来过，发的简餐也是留在下飞机的开阔地带迅速食用的，耳朵背后也勒出了很明显的红印。但一下飞机，就被西宁的天空吸引了，全然忘记了旅途当中的困顿和不适，那里的天空真的好低好蓝。接下来便和朋友一起去携程网点租车，还好Y哥在租车方面经验丰富，不然可能会吃不少亏。主要也就几个坑点吧 轮胎不在任何类别的保修，因此要格外注意。胎压监测大约2.5左右为正常(太高太低都不合适) 近光灯最好不要太暗也不要太亮，我们的车近光和远光一样，晚上时候被对面的人给闪瞎 可以问下能不能装 ETC，人工收费排队很长还有些只要现金的 提好了车，一行人便去附近超时囤物资，毕竟路上有很多无人区，必要的东西还是要先囤好(尤其是矿泉水)。(ps: 要是准备去茶卡盐湖的可以提前买好鞋套，手机防水袋啥的，到景区那边比较贵)从超市回来的时候遇到了西北的大风，由于在市区停车不好停，我们在裹挟着黄沙的大风中走了好久。对于我这老家山东祖籍太白的北方人倒没啥，不过估计也就是这阵风打消了y哥在这边定居的念头。 准备好物资我们就正式启程了，第一天的目标是到达黑马河乡，一个青海湖畔沐浴阳光的地方。可能是之前一直开手动挡的缘故，我感觉车的动力实在是有些小，油门踩到底速度都起得很慢，差点就有了换车的念头。所幸Y个见多识广教会了我正确的操作，不然一开始就换车真的很影响心情。随着汽车驶离西宁市区，我们也渐渐熟悉了车的状况(除了胎压监测一直显示过高)。一路上便听着网抑云音乐便欣赏着开阔壮美的景色，心情还是十分滴舒畅。 由于我们一直往西开，正好是追逐太阳的方向，有幸看到了此生最美的夕阳。直到九点左右太阳才真正收起了光芒，原来古人说的日落而息是没毛病的。前脚太阳落山，我们后脚就到了黑马河乡。 黑马河乡（Hei Ma He Xiang），位于青海省海南藏族自治州共和县县境西北部，距县府驻地148千米。人口4860人（2017）。面积1156.79平方千米，海拔3200米左右，是环湖线路的起点，也是看日出的最佳景点之一 可供选择的住宿地点不多，看起来像是个旅馆的更少，我们选择的是璀璨星辰，体验还不错，至少晚上没被冻醒。酒店前台还有类似的日出时间表，一切都被安排的明明白白 Day2伴随着闹铃，我们从温暖的被窝里爬了出来，被外面的温度给震惊到了。明明实在夏天，黑马河乡的温度却直逼零度，我们已经拿出了最厚的裤子和羽绒服，但是还是冻得瑟瑟发抖，只为早起去看那青海湖畔第一缕阳光。驱车10km左右我们到达了地图上的最佳地点，到了之后才发现湖边早已被围栏拦住，只留有很小的门口，当我们下车刚要进去时，远处传来了当地牧民的呼喊声。经过简单的交流才知道，进去是要给他们钱的，哈哈哈，果然是靠山吃山靠水吃水，靠青海湖畔吃太阳。由于外面天气太冷，我们也没敢多待，草草拍了几张合照便回宾馆附近去吃早饭了。黑马河乡虽然海拔不是太高，但在上面跑步明显能感受到心肺功能有所下降，吃罢早饭，一行人才逐渐有了活力，开始了接下来的旅程。我们计划在中午之前赶到茶卡盐湖，一个拥有天空之境美誉的地方 -to be continued","categories":[],"tags":[]},{"title":"Sliding Control","slug":"Sliding-Control","date":"2020-05-03T15:44:05.000Z","updated":"2020-10-08T14:43:30.528Z","comments":true,"path":"2020/05/03/Sliding-Control/","link":"","permalink":"http://example.com/2020/05/03/Sliding-Control/","excerpt":"","text":"滑膜变结构控制理论用到的定理里雅普诺夫稳定性第二定理 例子 滑膜变结构控制定义滑模变结构控制的原理，是根据系统所期望的动态特性来设计系统的切换超平面，通过滑动模态控制器使系统状态从超平面之外向切换超平面收束。系统一旦到达切换超平面，控制作用将保证系统沿切换超平面到达系统原点，这一沿切换超平面向原点滑动的过程称为滑模控制。 滑膜控制器的设计过程 确定动力学方程 定义状态变量 ： e = 目标值 - 实际值 确定滑膜变量（形式一般固定）S = λe+e’ 定义李雅普诺夫函数（需满足开头所讲定理）V = S^2 / 2 带入求解得到最终方程 …. 具体应用 - 两轮平衡车 动力学方程确定 定义状态变量 确定滑膜变量 定义李雅普诺夫函数 求解方程 程序编写 1u_SMC(i) &#x3D; sat(i)*(J*k*abs(e_D(i)) + C*(sita_D(i)) + D);","categories":[],"tags":[]},{"title":"DS-C","slug":"DS-C","date":"2020-01-06T15:43:24.000Z","updated":"2020-10-08T14:42:45.387Z","comments":true,"path":"2020/01/06/DS-C/","link":"","permalink":"http://example.com/2020/01/06/DS-C/","excerpt":"","text":"05-树7 堆中的路径 (25 分)将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。 输入格式:每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。 输出格式:对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。 输入样例:5 346 23 26 24 105 4 3 输出样例:24 23 1046 23 1026 10 Note1.插入的思想: 在一个有序的最小堆里插入道最后，与其父节点比较，若小于其父节点，父节点下移 Code1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;#define MIN -10001int a[1001];int size &#x3D; 0;void Insert(int n) &#123; int i; for( i &#x3D; ++size; n &lt; a[i&#x2F;2]; i &#x2F;&#x3D; 2)&#123; a[i] &#x3D; a[i&#x2F;2]; &#125; a[i] &#x3D; n;&#125;int main() &#123; int num, check; a[0] &#x3D; MIN; cin &gt;&gt; num &gt;&gt; check; for(int i &#x3D; 0; i &lt; num; i++) &#123; int temp; cin &gt;&gt; temp; Insert(temp); &#125; for(int i &#x3D; 0; i &lt; check; i++) &#123; int temp; cin &gt;&gt; temp; cout &lt;&lt; a[temp]; for(int j &#x3D; temp; j &gt; 1; j &#x2F;&#x3D; 2)&#123; cout &lt;&lt; &quot; &quot; &lt;&lt; a[j&#x2F;2]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 05-树8 File Transfer (25 分)We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other? Input Specification:Each input file contains one test case. For each test case, the first line contains N (2≤N≤10​4​​ ), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format: I c1 c2where I stands for inputting a connection between c1 and c2; or C c1 c2where C stands for checking if it is possible to transfer files between c1 and c2; or Swhere S stands for stopping this case. Output Specification:For each C case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between c1 and c2, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are k components.” where k is the number of connected components in this network. Sample Input 1:5C 3 2I 3 2C 1 5I 4 5I 2 4C 3 5S Sample Output 1:nonoyesThere are 2 components. Sample Input 2:5C 3 2I 3 2C 1 5I 4 5I 2 4C 3 5I 1 3C 1 5S Sample Output 2:nonoyesyesThe network is connected. Note1 思路：并查集的查和并， data域用数组下标表示，parent为数组中的内容， -1代表是根， 查：若不是根就一直查，返回根 并： 直接把两个合并，（有问题，不能保证两个集合归并，只能保证一个集合和以另一个元素为根的子集的归并） vector 全局变量失败？ 退出时还在等两个元素输入，debug了好长时间 结果 1个超时点 + 1个错误点Code112345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int s[100010];int Find(int s[], int x) &#123; for(; s[x - 1] &gt;&#x3D; 0; x &#x3D; s[x - 1]); return x;&#125;void Union (int s[], int r1, int r2) &#123; s[r2 - 1] &#x3D; r1;&#125;int main() &#123; int num; cin &gt;&gt; num; for(int i &#x3D; 0; i &lt; num; i++) s[i] &#x3D; -1; while(1) &#123; char temp; int p1, p2; cin &gt;&gt; temp; if(temp &#x3D;&#x3D; &#39;C&#39;) &#123; cin &gt;&gt; p1 &gt;&gt; p2; if(Find(s, p1) &#x3D;&#x3D; Find(s, p2)) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; &#125; else if(temp &#x3D;&#x3D; &#39;I&#39;)&#123; cin &gt;&gt; p1 &gt;&gt; p2; Union(s, p1, p2); &#125; else if(temp &#x3D;&#x3D; &#39;S&#39;) &#123; int cnt &#x3D; 0; for(int j &#x3D; 0; j &lt; num; j++)&#123; if(s[j] &#x3D;&#x3D; -1) cnt++; &#125; if(cnt &#x3D;&#x3D; 1) cout &lt;&lt; &quot;The network is connected.&quot;; else cout &lt;&lt; &quot;There are &quot; &lt;&lt; cnt &lt;&lt;&quot; components.&quot;; break; &#125; &#125; return 0;&#125; Note2 路径压缩： 在每次find的时候把树的高度降低，使之后的find速度更快 按质归并： 将矮的树归并到高的树上（原因：新的树的高度认为原来高树的高度） 并： 改为两个根节点的并Code212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int s[100010];int Find(int s[], int x) &#123; if(s[x] &lt; 0) return x; else return s[x] &#x3D; Find(s, s[x] );&#125;void Union (int s[], int r1, int r2) &#123; if(s[r2] &lt; s[r1])&#123; s[r1] &#x3D; r2; &#125; else&#123; if(s[r1] &#x3D;&#x3D; s[r2]) s[r1]--; s[r2] &#x3D; r1; &#125;&#125;int main() &#123; int num; cin &gt;&gt; num; for(int i &#x3D; 0; i &lt; num; i++) s[i] &#x3D; -1; while(1) &#123; char temp; int p1, p2; cin &gt;&gt; temp; if(temp &#x3D;&#x3D; &#39;C&#39;) &#123; cin &gt;&gt; p1 &gt;&gt; p2; p1 &#x3D; Find(s, p1 - 1); p2 &#x3D; Find(s, p2 - 1); if(p1 &#x3D;&#x3D; p2) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; &#125; else if(temp &#x3D;&#x3D; &#39;I&#39;)&#123; cin &gt;&gt; p1 &gt;&gt; p2; p1 &#x3D; Find(s, p1 - 1); p2 &#x3D; Find(s, p2 - 1); Union(s, p1, p2); &#125; else if(temp &#x3D;&#x3D; &#39;S&#39;) &#123; int cnt &#x3D; 0; for(int j &#x3D; 0; j &lt; num; j++)&#123; if(s[j] &lt;&#x3D; -1) cnt++; &#125; if(cnt &#x3D;&#x3D; 1) cout &lt;&lt; &quot;The network is connected.&quot;; else cout &lt;&lt; &quot;There are &quot; &lt;&lt; cnt &lt;&lt;&quot; components.&quot;; break; &#125; &#125; return 0;&#125; 06-图1 列出连通集 (25 分)给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。 输入格式:输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。 输出格式:按照”{ v1 v​2​ … v​k​ }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。 输入样例:8 60 70 12 04 12 43 5 输出样例:{ 0 1 4 2 7 }{ 3 5 }{ 6 }{ 0 1 2 7 4 }{ 3 5 }{ 6 } Notes 最简单的邻接矩阵的BFS和DFS, BFS利用队列，DFS用递归Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#define MAX 10010int a[MAX][MAX];int Dfs_visited[MAX] &#x3D; &#123;0&#125;, Bfs_visited[MAX] &#x3D; &#123;0&#125;;int Qnum, Lnum;void Bfs(void)&#123; int i,j; for(i &#x3D; 0; i &lt; Qnum; i++)&#123; if(Bfs_visited[i] &#x3D;&#x3D; 0)&#123; queue&lt;int&gt; q; q.push(i); cout &lt;&lt; &quot;&#123; &quot;; cout &lt;&lt; i &lt;&lt; &quot; &quot;; Bfs_visited[i] &#x3D; 1; &#x2F;&#x2F;访问连同子图的第一个元素 while(q.size() &gt; 0) &#123; int temp &#x3D; q.front(); q.pop(); for(j &#x3D; 0; j &lt; Qnum; j++) &#123; if(a[temp][j] &#x3D;&#x3D; 1 &amp;&amp; Bfs_visited[j] &#x3D;&#x3D; 0)&#123; cout &lt;&lt; j &lt;&lt; &quot; &quot;; Bfs_visited[j] &#x3D; 1; q.push(j); &#125; &#125; &#125; cout &lt;&lt; &quot;&#125;&quot; &lt;&lt; endl; &#125; &#125;&#125;void Dfs(int i) &#123; for(int j &#x3D; 0; j &lt; Qnum; j++) &#123; if(a[i][j] &#x3D;&#x3D; 1 &amp;&amp; Dfs_visited[j] &#x3D;&#x3D; 0)&#123; cout &lt;&lt; j &lt;&lt; &quot; &quot;; Dfs_visited[j] &#x3D; 1; Dfs(j); &#125; &#125;&#125;void DfsTraverse(void) &#123; for(int i &#x3D; 0; i &lt; Qnum; i++)&#123; if(Dfs_visited[i] &#x3D;&#x3D; 0)&#123; cout &lt;&lt; &quot;&#123; &quot;; cout &lt;&lt; i &lt;&lt; &quot; &quot;; Dfs_visited[i] &#x3D; 1; &#x2F;&#x2F;访问连同子图的第一个元素 Dfs(i); cout &lt;&lt; &quot;&#125;&quot; &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; Qnum &gt;&gt; Lnum; for(int i &#x3D; 0; i &lt; Qnum; i++)&#123; for(int j &#x3D; 0; j &lt; Qnum; j++)&#123; a[i][j] &#x3D; 0; &#125; &#125; for(int K &#x3D; 0; K &lt; Lnum; K++) &#123; int i, j; cin &gt;&gt; i &gt;&gt; j; a[i][j] &#x3D; 1; a[j][i] &#x3D; 1; &#125; DfsTraverse(); Bfs(); return 0;&#125;","categories":[],"tags":[]},{"title":"考研规划","slug":"考研规划","date":"2020-01-06T08:23:16.000Z","updated":"2020-10-06T15:12:04.904Z","comments":true,"path":"2020/01/06/考研规划/","link":"","permalink":"http://example.com/2020/01/06/%E8%80%83%E7%A0%94%E8%A7%84%E5%88%92/","excerpt":"","text":"基础阶段（3-6月）数学 高数：杨超高数基础班+课本和张宇十八讲的注意点部分+1800题基础部分 现代：李永乐线代基础班+线性代数辅导讲义 1800：平均一周做完一章稍微多一点（一章100题）视频：一周一章多一点（一章6小时左右） 英语 曲根10000过完 onenote复习 新题型和作文的视频 4085月初-6月末 60t： 操作系统的课本复习加笔记整理+王道的所有题目 计算机网络王道视频+王道题目+计网topdown重点内容理解 清航四科视频 强化阶段（7-9月）数学：7月初-7月末30t：7月初-7月末30t： 7月初-7月末30t： 8月初-8月末30t： 专业课： 7月初-7月末30t： 8月初-8月末30t： PAT: 7月初 - 8月末 政治 7月初 - 8月末 看张宇强化视频 ——做英——记录408电子版笔记——看政治强化视频 真题阶段：（9月）数学： 9月8-9月末22t： 专业课： 9月8-9月末22t： PAT： 9月1-9月末7t 政治 9月8-9月末22t 冲刺阶段（10-12月)数学 数学张宇六套卷 汤家凤七套卷 李永乐八套卷 李林六套卷 超越六套卷 闭关修炼错题 辅导讲义错题，1800错题 真题错题专题训练 + 01 - 10小题训练 难点重点复习 英语 真题 17- 19 全真模拟 10 - 15 研究题型， 作文准备 政治 肖八套选择 难点加强巩固1000题多选 408体系完善","categories":[],"tags":[]},{"title":"DS-B","slug":"DS-B","date":"2019-10-20T15:31:41.000Z","updated":"2020-10-08T14:42:38.726Z","comments":true,"path":"2019/10/20/DS-B/","link":"","permalink":"http://example.com/2019/10/20/DS-B/","excerpt":"","text":"04-树5 Root of AVL Tree (25 分)An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, print the root of the resulting AVL tree in one line. Sample Input 1:588 70 61 96 120 Sample Output 1:70 Sample Input 2:788 70 61 96 120 90 65 Sample Output 2:88 思路1.高度利用递归求解，不设height域 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;typedef struct AVLNode* AVL;struct AVLNode &#123; int data; AVL left; AVL right;&#125;;int GetHight(AVL T) &#123; if(!T) return 0; else return max(GetHight(T-&gt;left), GetHight(T-&gt;right)) + 1;&#125;AVL LeftLeft(AVL T)&#123; AVL temp &#x3D; T-&gt;left; T-&gt;left &#x3D; temp-&gt;right; temp-&gt;right &#x3D; T; return temp;&#125;AVL RightRight(AVL T) &#123; AVL temp &#x3D; T-&gt;right; T-&gt;right &#x3D; temp-&gt;left; temp-&gt;left &#x3D; T; return temp;&#125;AVL LeftRight(AVL T) &#123; AVL temp &#x3D; T-&gt;left; T-&gt;left &#x3D; RightRight(temp); return LeftLeft(T);&#125;AVL RightLeft(AVL T) &#123; AVL temp &#x3D; T-&gt;right; T-&gt;right &#x3D; LeftLeft (temp); return RightRight(T);&#125;AVL Insert(AVL T, int data) &#123; if(!T) &#123; T &#x3D; (AVL)malloc (sizeof(struct AVLNode)); T-&gt;data &#x3D; data; T-&gt;left &#x3D; NULL; T-&gt;right &#x3D; NULL; &#125; else if(data &lt; T-&gt;data)&#123; T-&gt;left &#x3D; Insert(T-&gt;left, data); if(GetHight(T-&gt;left) - GetHight(T-&gt;right) &#x3D;&#x3D; 2) &#123; if(data &lt; T-&gt;left-&gt;data) &#123; T &#x3D; LeftLeft(T); &#125; else &#123; T &#x3D; LeftRight(T); &#125; &#125; &#125; else if(data &gt; T-&gt;data)&#123; T-&gt;right &#x3D; Insert(T-&gt;right, data); if(GetHight(T-&gt;left) - GetHight(T-&gt;right) &#x3D;&#x3D; -2) &#123; if(data &gt; T-&gt;right-&gt;data) &#123; T &#x3D; RightRight(T); &#125; else &#123; T &#x3D; RightLeft(T); &#125; &#125; &#125; return T;&#125;int main() &#123; AVL T &#x3D; NULL; int num, data; cin &gt;&gt; num; for(int i &#x3D; 0; i &lt; num; i++) &#123; cin &gt;&gt; data; T &#x3D; Insert(T, data); &#125; cout &lt;&lt; T-&gt;data; return 0;&#125; 04-树6 Complete Binary Search Tree (30 分)A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000. Output Specification:For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input:101 2 3 4 5 6 7 8 9 0 Sample Output:6 3 8 1 5 7 9 0 2 4 思路 先假装建树，中序搜索，找到位置填入Code1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;int a[2100];int main() &#123; int num; int cnt &#x3D; 0; cin &gt;&gt; num; vector&lt;int&gt; input(num); for(int i &#x3D; 0; i &lt; num; i++)&#123; cin &gt;&gt; input[i]; &#125; sort(input.begin(), input.end()); stack&lt;int&gt; s; s.push(1); while(s.size() &gt; 0)&#123; int p &#x3D; s.top(); while(p &lt;&#x3D; num)&#123; p &#x3D; p * 2; s.push(p);&#125; s.pop(); if(s.size() &gt; 0)&#123; p &#x3D; s.top(); s.pop(); a[p] &#x3D; input[cnt++]; s.push(2 * p + 1); &#125; &#125; for(int i &#x3D; 1; i &lt;&#x3D; num; i++)&#123; cout &lt;&lt; a[i] ; if(i &lt; num) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 04-树7 二叉搜索树的操作集 (30 分)本题要求实现给定二叉搜索树的5种常用操作。 函数接口定义：BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST ); 其中BinTree结构定义如下：typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;};函数Insert将X插入二叉搜索树BST并返回结果树的根结点指针；函数Delete将X从二叉搜索树BST中删除，并返回结果树的根结点指针；如果X不在树中，则打印一行Not Found并返回原树的根结点指针；函数Find在二叉搜索树BST中找到X，返回该结点的指针；如果找不到则返回空指针；函数FindMin返回二叉搜索树BST中最小元结点的指针；函数FindMax返回二叉搜索树BST中最大元结点的指针。 裁判测试程序样例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;;void PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;void InorderTraversal( BinTree BT ); &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123; BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST &#x3D; NULL; scanf(&quot;%d&quot;, &amp;N); for ( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); BST &#x3D; Insert(BST, X); &#125; printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\\n&quot;); MinP &#x3D; FindMin(BST); MaxP &#x3D; FindMax(BST); scanf(&quot;%d&quot;, &amp;N); for( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); Tmp &#x3D; Find(BST, X); if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\\n&quot;, X); else &#123; printf(&quot;%d is found\\n&quot;, Tmp-&gt;Data); if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\\n&quot;, Tmp-&gt;Data); if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\\n&quot;, Tmp-&gt;Data); &#125; &#125; scanf(&quot;%d&quot;, &amp;N); for( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); BST &#x3D; Delete(BST, X); &#125; printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\\n&quot;); return 0;&#125;&#x2F;* 你的代码将被嵌在这里 *&#x2F; 输入样例：105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3 输出样例：Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9 Notes 当删除节点左右孩子都不空时，找到左子树的最大节点（可以不用循环） 对递归的出口不是很清晰，diyibianbug出耗费了很长时间 若递归出不加return，那只有第一层可以正常返回，第二层顺序执行完便强制返回0. left！= null &amp;&amp; right == null – right == null &amp;&amp; left != null …….code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465BinTree Delete( BinTree BST, ElementType X )&#123; if(BST &#x3D;&#x3D; NULL)&#123; printf(&quot;Not Found\\n&quot;); return BST;&#125; else if(BST-&gt;Data &#x3D;&#x3D; X)&#123; if(BST-&gt;Left !&#x3D; NULL &amp;&amp; BST-&gt;Right !&#x3D; NULL)&#123; BinTree p &#x3D; FindMax(BST-&gt;Left); &#x2F;&#x2F;while(p-&gt;Right) p &#x3D; p-&gt;Right; p-&gt;Right &#x3D; BST-&gt;Right; p &#x3D; BST-&gt;Left; free(BST); return p; &#125; else if(BST-&gt;Left !&#x3D; NULL &amp;&amp; BST-&gt;Right &#x3D;&#x3D; NULL)&#123; BinTree p &#x3D; BST-&gt;Left; free(BST); return p; &#125; else if(BST-&gt;Right !&#x3D; NULL &amp;&amp; BST-&gt;Left &#x3D;&#x3D; NULL)&#123; BinTree p &#x3D; BST-&gt;Right; free(BST); return p; &#125; else if((BST-&gt;Left !&#x3D; NULL) &amp;&amp; (BST-&gt;Right &#x3D;&#x3D; NULL))&#123; BinTree p &#x3D; BST; free(p); return NULL; &#125; &#125; else if(X &lt; BST-&gt;Data) &#123; BST-&gt;Left &#x3D; Delete(BST-&gt;Left, X); return BST; &#125; else if(X &gt; BST-&gt;Data)&#123; BST-&gt;Right &#x3D; Delete(BST-&gt;Right, X); return BST;&#125;&#125;BinTree Insert( BinTree BST, ElementType X ) &#123; if(BST &#x3D;&#x3D; NULL)&#123; BST &#x3D; (BinTree)malloc(sizeof(Position)); BST-&gt;Data &#x3D; X; BST-&gt;Left &#x3D; NULL; BST-&gt;Right &#x3D; NULL; &#125; else if(X &gt; BST-&gt;Data) BST-&gt;Right &#x3D;Insert(BST-&gt;Right, X); else if(X &lt; BST-&gt;Data) BST-&gt;Left &#x3D; Insert(BST-&gt;Left, X); return BST;&#125;&#x2F;&#x2F;diyidabug Position Find( BinTree BST, ElementType X )&#123; if(BST &#x3D;&#x3D; NULL) return 0; else if(BST-&gt;Data &#x3D;&#x3D; X) return BST; else if(X &lt; BST-&gt;Data) Find(BST-&gt;Left, X); else Find(BST-&gt;Right, X);&#125;Position FindMin( BinTree BST )&#123; if(!BST) return BST; if(BST-&gt;Left &#x3D;&#x3D; NULL) return BST; else FindMin(BST-&gt;Left);&#125;Position FindMax( BinTree BST )&#123; if(!BST) return BST; if(BST-&gt;Right &#x3D;&#x3D; NULL) return BST; else FindMax(BST-&gt;Right);&#125; 完全实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;;void PreorderTraversal( BinTree BT ); &#x2F;* 先序遍历，由裁判实现，细节不表 *&#x2F;void InorderTraversal( BinTree BT ); &#x2F;* 中序遍历，由裁判实现，细节不表 *&#x2F;BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123; BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST &#x3D; NULL; scanf(&quot;%d&quot;, &amp;N); for ( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); BST &#x3D; Insert(BST, X); &#125; printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\\n&quot;); MinP &#x3D; FindMin(BST); MaxP &#x3D; FindMax(BST); scanf(&quot;%d&quot;, &amp;N); for( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); Tmp &#x3D; Find(BST, X); if (Tmp &#x3D;&#x3D; NULL) printf(&quot;%d is not found\\n&quot;, X); else &#123; printf(&quot;%d is found\\n&quot;, Tmp-&gt;Data); if (Tmp&#x3D;&#x3D;MinP) printf(&quot;%d is the smallest key\\n&quot;, Tmp-&gt;Data); if (Tmp&#x3D;&#x3D;MaxP) printf(&quot;%d is the largest key\\n&quot;, Tmp-&gt;Data); &#125; &#125; scanf(&quot;%d&quot;, &amp;N); for( i&#x3D;0; i&lt;N; i++ ) &#123; scanf(&quot;%d&quot;, &amp;X); BST &#x3D; Delete(BST, X); &#125; printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\\n&quot;); return 0;&#125;BinTree Delete( BinTree BST, ElementType X )&#123; if(BST &#x3D;&#x3D; NULL)&#123; printf(&quot;Not Found\\n&quot;); return BST;&#125; else if(BST-&gt;Data &#x3D;&#x3D; X)&#123; if(BST-&gt;Left !&#x3D; NULL &amp;&amp; BST-&gt;Right !&#x3D; NULL)&#123; BinTree p &#x3D; BST-&gt;Left; while(p-&gt;Right) p &#x3D; p-&gt;Right; p-&gt;Right &#x3D; BST-&gt;Right; p &#x3D; BST-&gt;Left; &#x2F;&#x2F;free(BST); return p; &#125; else if(BST-&gt;Left !&#x3D; NULL &amp;&amp; BST-&gt;Right &#x3D;&#x3D; NULL)&#123; BinTree p &#x3D; BST-&gt;Left; &#x2F;&#x2F;free(BST); return p; &#125; else if(BST-&gt;Right !&#x3D; NULL &amp;&amp; BST-&gt;Left &#x3D;&#x3D; NULL)&#123; BinTree p &#x3D; BST-&gt;Right; &#x2F;&#x2F;free(BST); return p; &#125; else&#123; BinTree p &#x3D; BST; &#x2F;&#x2F;free(p); return NULL; &#125; &#125; else if(X &lt; BST-&gt;Data) &#123; BST-&gt;Left &#x3D; Delete(BST-&gt;Left, X); return BST; &#125; else&#123; BST-&gt;Right &#x3D; Delete(BST-&gt;Right, X); return BST;&#125;&#125;BinTree Insert( BinTree BST, ElementType X ) &#123; if(BST &#x3D;&#x3D; NULL)&#123; BST &#x3D; (BinTree)malloc(sizeof(Position)); BST-&gt;Data &#x3D; X; BST-&gt;Left &#x3D; NULL; BST-&gt;Right &#x3D; NULL; &#125; else if(X &gt; BST-&gt;Data) BST-&gt;Right &#x3D;Insert(BST-&gt;Right, X); else if(X &lt; BST-&gt;Data) BST-&gt;Left &#x3D; Insert(BST-&gt;Left, X); return BST;&#125;&#x2F;&#x2F;diyidabug Position Find( BinTree BST, ElementType X )&#123; if(BST &#x3D;&#x3D; NULL) return 0; else if(BST-&gt;Data &#x3D;&#x3D; X) return BST; else if(X &lt; BST-&gt;Data) Find(BST-&gt;Left, X); else Find(BST-&gt;Right, X);&#125;Position FindMin( BinTree BST )&#123; if(BST-&gt;Left &#x3D;&#x3D; NULL) return BST; else FindMin(BST-&gt;Left);&#125;Position FindMax( BinTree BST )&#123; if(BST-&gt;Right &#x3D;&#x3D; NULL) return BST; else FindMax(BST-&gt;Right);&#125;void InorderTraversal( BinTree BT )&#123; stack&lt;BinTree&gt; s; s.push(BT); while(s.size() &gt; 0)&#123; BinTree temp &#x3D; s.top(); while(temp) &#123;temp &#x3D; temp-&gt;Left; s.push(temp);&#125; s.pop(); if(s.size() &gt; 0)&#123; temp &#x3D; s.top(); s.pop(); cout &lt;&lt; temp-&gt;Data &lt;&lt; &quot; &quot;; s.push(temp-&gt;Right); &#125; &#125;&#125;void PreorderTraversal( BinTree BT )&#123; stack&lt;BinTree&gt; s; s.push(BT); while(s.size() &gt; 0)&#123; BinTree temp &#x3D; s.top(); while(temp) &#123; cout &lt;&lt;( temp-&gt;Data)&lt;&lt; &quot; &quot;; temp &#x3D; temp-&gt;Left; s.push(temp);&#125; s.pop(); if(s.size() &gt; 0)&#123; temp &#x3D; s.top(); s.pop(); s.push(temp-&gt;Right); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"DS-A","slug":"DS-A","date":"2019-10-08T15:31:33.000Z","updated":"2020-10-08T14:42:24.348Z","comments":true,"path":"2019/10/08/DS-A/","link":"","permalink":"http://example.com/2019/10/08/DS-A/","excerpt":"","text":"02-线性结构1 两个有序链表序列的合并 （15 分)本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。 函数接口定义：List Merge( List L1, List L2 );其中List结构定义如下： typedef struct Node PtrToNode;struct Node { ElementType Data; / 存储结点数据 / PtrToNode Next; / 指向下一个结点的指针 /};typedef PtrToNode List; / 定义单链表类型 */L1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。 裁判测试程序样例：#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; typedef int ElementType;typedef struct Node *PtrToNode;struct Node { ElementType Data; PtrToNode Next;};typedef PtrToNode List; List Read(); /* 细节在此不表 /void Print( List L ); / 细节在此不表；空链表将输出NULL */ List Merge( List L1, List L2 ); int main(){ List L1, L2, L; L1 = Read(); L2 = Read(); L = Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;} /* 你的代码将被嵌在这里 */ 输入样例：31 3 552 4 6 8 10 输出样例：1 2 3 4 5 6 8 10NULLNULL 分析 题目简单，但读题不仔细，刚开始想用之前头节点直接当新的头，没考虑到输出L1 L2 提交有问题一直说Node没有定义， 索性直接把所有的函数都具体实现一边，跑完没有问题。代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List; List Read(); &#x2F;* 细节在此表 *&#x2F;void Print( List L ); &#x2F;* 细节在此不表；空链表将输出NULL *&#x2F; List Merge( List L1, List L2 ); int main()&#123; List L1, L2, L; L1 &#x3D; Read(); L2 &#x3D; Read(); L &#x3D; Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125; List Read()&#123; int num; scanf(&quot;%d&quot;, &amp;num); List L &#x3D; (List)malloc(sizeof( Node)); L-&gt;Next &#x3D; NULL; List tail; tail &#x3D; L; for (int i &#x3D; 0; i &lt; num; ++i) &#123; int data; scanf(&quot;%d&quot;, &amp;data); List pNode &#x3D; (List)malloc(sizeof(Node)); pNode -&gt; Data &#x3D; data; tail -&gt; Next &#x3D; pNode; tail &#x3D; pNode; &#125; tail -&gt; Next &#x3D; NULL; return L;&#125; void Print(List L)&#123; List pNode &#x3D; L-&gt;Next; if (pNode &#x3D;&#x3D; NULL)&#123; printf(&quot;NULL\\n&quot;); return; &#125; while(pNode !&#x3D; NULL)&#123; printf(&quot;%d &quot;, pNode-&gt;Data); pNode &#x3D; pNode-&gt;Next; &#125; printf(&quot;\\n&quot;);&#125; List Merge( List L1, List L2 )&#123; List L3&#x3D;(List)malloc(sizeof(Node)); List L&#x3D;L3; List p&#x3D;L1-&gt;Next; List q&#x3D;L2-&gt;Next; while(p&amp;&amp;q) &#123; if(p-&gt;Data&lt;q-&gt;Data) &#123; L-&gt;Next&#x3D;p; p&#x3D;p-&gt;Next; &#125; else &#123; L-&gt;Next&#x3D;q; q&#x3D;q-&gt;Next; &#125; L&#x3D;L-&gt;Next; &#125; L-&gt;Next&#x3D;p ? p : q; L1-&gt;Next&#x3D;NULL; L2-&gt;Next&#x3D;NULL; return L3;&#125; 类似题目：链表重排（25 分）Problem Description给定一条单链表，将链表结点进行头尾交错重新排序，即如果一条单链表为 L1 -&gt; L2 -&gt; … -&gt; L(n-1) -&gt; Ln ，那么重新排序完的结果是 L1 -&gt; Ln -&gt; L2 -&gt; L(n-1) -&gt; L3 -&gt; L(n-2) -&gt; … Input每个输入文件中一组数据。 第一行给出结点的总个数N（0&lt;N&lt;10^5）和单链表的第一个结点的地址。所有结点的地址要么是一个五位正整数，要么是用-1表示的空地址NULL。然后是N行，表示N个结点，每行的格式为 Address Data Next其中Address为结点地址（不足5位的高位用零填充至5位），Data为结点的数据域（绝对值不超过10^5的整数），Next为结点的指针域（即下一个结点的地址）。数据保证Address不等于-1。 Output输出按题目要求重新排序后的单链表。第一行为重新排序后单链表上结点的个数、第一个结点的地址。 之后每行一个结点，输出格式与输入相同，结点输出顺序为单链表连接顺序。 Sample Input5 1111133333 0 4444422222 2 3333311111 5 2222205689 8 -144444 6 05689Sample Output5 1111111111 5 0568905689 8 2222222222 2 4444444444 6 3333333333 0 -1 Address： https://logn.me/problem/1042Note1 思路有些清奇，以为int型装不下，用的字符串 。正排一边 ， 正序逆序记录两次，交替输出前一半。 ——超时 Code11234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define MAX 100100struct Node&#123; char address[7]; int data; char next[7];&#125;a[MAX], sort1[MAX], sort2[MAX];int main()&#123; int num; char temp[7], start[7]; scanf(&quot;%d %s&quot;, &amp;num, start); for(int i &#x3D; 0; i &lt; num; i++)&#123; scanf(&quot;%s %d %s&quot;, a[i].address, &amp;a[i].data, a[i].next); &#125; int cnt &#x3D; 0; strcpy(temp, start); int i; while(cnt &lt; num)&#123; for(i &#x3D; 0; strcmp(a[i].address, temp) !&#x3D; 0; i++); sort1[cnt++] &#x3D; a[i]; sort2[num - cnt] &#x3D; a[i]; strcpy(temp , a[i].next); &#125; if(num % 2 &#x3D;&#x3D; 0) strcpy(sort1[num&#x2F;2 + 1].address, &quot;-1&quot;); else strcpy(sort2[num&#x2F;2].address, &quot;-1&quot;); printf(&quot;%d %s\\n&quot;, num, start); for(i &#x3D; 0; i &lt;&#x3D; num&#x2F;2; i++)&#123; printf(&quot;%s %d %s\\n&quot;, sort1[i].address, sort1[i].data, sort2[i].address); if(!(num % 2 &#x3D;&#x3D; 1 &amp;&amp; i &#x3D;&#x3D; num &#x2F; 2)) printf(&quot;%s %d %s\\n&quot;, sort2[i].address, sort2[i].data, sort1[i + 1].address ); &#125;&#125; Note2 用int型存储，利用地址直接哈希， 排序完后记录会去 const int maxn = 1e5 + 10 值得借鉴的用法Code2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int maxn&#x3D;1e5+10;struct Node&#123; int ad,next,data;&#125;a[maxn],ans[maxn]; int main()&#123; int ptr,num,address; scanf(&quot;%d %d&quot;,&amp;num, &amp;ptr ); for(int i &#x3D; 0; i &lt; num; i++) &#123; scanf(&quot;%d&quot;, &amp;address); scanf(&quot;%d %d&quot;, &amp;a[address].data, &amp;a[address].next); &#125; int cnt&#x3D;1; printf(&quot;%d %05d\\n&quot;, num, ptr); while(ptr !&#x3D; -1)&#123; ans[cnt].ad &#x3D; ptr; ans[cnt++].data &#x3D; a[ptr].data; ptr &#x3D; a[ptr].next; &#125; for(int i &#x3D; 1; i &lt; cnt ; i++)&#123; if(i%2 &#x3D;&#x3D; 0) a[i] &#x3D; ans[cnt - i&#x2F;2]; else a[i] &#x3D; ans[i&#x2F;2 + 1]; &#125; for(int i &#x3D; 1; i &lt; cnt-1; i++)&#123; printf(&quot;%05d %d %05d\\n&quot;,a[i].ad, a[i].data, a[i+1].ad); &#125; printf(&quot;%05d %d -1\\n&quot;, a[cnt-1].ad, a[cnt-1].data); return 0;&#125;# 02-线性结构2 一元多项式的乘法与加法运算 （20 分)设计函数分别求两个一元多项式的乘积与和。## 输入格式:输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。## 输出格式:输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。## 输入样例:4 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1## 输出样例:15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0## 分析1.是不是pat改版改的哇， 两到题都有些问题过不了，测试点3输入有零多项式和常数多项式不管是输出还是不输出系数为零的多项式，都有错误。## 代码&#96;&#96;&#96;&#96;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; typedef struct PolyNode *Polynomial;int length &#x3D; 0;struct PolyNode &#123; int coef; int expon; Polynomial link;&#125;;void Attach(int c, int e, Polynomial* pRear)&#123; Polynomial P; P &#x3D; (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef &#x3D; c; P-&gt;expon &#x3D; e; P-&gt;link &#x3D; NULL; (*pRear)-&gt;link &#x3D; P; *pRear &#x3D; P;&#125;Polynomial ReadPoly (void)&#123; Polynomial P,Rear,t; int n; int c; int e; scanf(&quot;%d&quot;, &amp;n); P &#x3D; (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link &#x3D; NULL; Rear &#x3D; P; while(n--) &#123; scanf(&quot;%d %d&quot;, &amp;c, &amp;e); Attach(c, e, &amp;Rear); &#125; t &#x3D; P; P &#x3D; P-&gt;link; free(t); return P;&#125;Polynomial Mult(Polynomial P1, Polynomial P2)&#123; Polynomial t1,t2,P,Rear,t; int e; int c; if(!P1||!P2) return NULL; t1 &#x3D; P1; t2 &#x3D; P2; P &#x3D; (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link &#x3D; NULL; Rear&#x3D;P; while(t2) &#123; Attach(t1-&gt;coef*t2-&gt;coef,t1-&gt;expon+t2-&gt;expon,&amp;Rear); t2 &#x3D; t2-&gt;link; length++; &#125; t1 &#x3D; t1-&gt;link; while(t1) &#123; Rear &#x3D; P; t2 &#x3D; P2; while(t2) &#123; c &#x3D; t1-&gt;coef*t2-&gt;coef; e &#x3D; t1-&gt;expon+t2-&gt;expon; while(Rear-&gt;link&amp;&amp;Rear-&gt;link-&gt;expon&gt;e) Rear&#x3D;Rear-&gt;link; if(Rear-&gt;link &amp;&amp;Rear-&gt;link-&gt;expon&#x3D;&#x3D;e)&#x2F;&#x2F;Rear-&gt;link╢Макр╩мМио &#123; if(Rear-&gt;link-&gt;coef+c) Rear-&gt;link-&gt;coef+&#x3D;c; else&#123; t &#x3D; Rear-&gt;link; Rear-&gt;link &#x3D; t-&gt;link; free(t); length--; &#125; &#125; else&#123; t &#x3D; (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef &#x3D; c; t-&gt;expon&#x3D;e; t-&gt;link &#x3D; Rear-&gt;link; Rear-&gt;link &#x3D;t; Rear &#x3D; Rear-&gt;link;&#x2F;&#x2F;? length++; &#125; t2 &#x3D; t2-&gt;link; &#125; t1 &#x3D; t1-&gt;link; &#125; t &#x3D; P; P &#x3D; P-&gt;link; free(t); return P;&#125;void Print(Polynomial P)&#123; int flag &#x3D; 0; int cnt &#x3D; 0; if (!P) &#123;printf(&quot;0 0\\n&quot;); return;&#125; while(P) &#123; if(!flag) flag &#x3D; 1; else&#123; printf(&quot; &quot;); &#125; printf(&quot;%d %d&quot;, P-&gt;coef ,P-&gt;expon ); cnt ++; P &#x3D; P-&gt;link; &#125; printf(&quot;\\n&quot;);&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial t1,t2,P,Rear,t; int e; int c; if(!P1||!P2) return NULL; t1 &#x3D; P1; t2 &#x3D; P2; P&#x3D;(Polynomial)malloc(sizeof(struct PolyNode)); Rear &#x3D; P; while(t1 &amp;&amp; t2) &#123; if(t1 -&gt; expon &#x3D;&#x3D; t2 -&gt; expon)&#123; if(t1 -&gt; coef !&#x3D; -(t2 -&gt; coef)) Attach(t1 -&gt; coef + t2 -&gt; coef, t1 -&gt; expon, &amp;Rear); t1 &#x3D; t1 -&gt; link; t2 &#x3D; t2 -&gt; link; &#125; else if(t1 -&gt; expon &gt; t2 -&gt; expon)&#123; Attach(t1 -&gt; coef, t1 -&gt; expon, &amp;Rear); t1 &#x3D; t1 -&gt; link; &#125; else &#123; Attach(t2 -&gt; coef, t2 -&gt; expon, &amp;Rear); t2 &#x3D; t2 -&gt; link; &#125; &#125; Rear -&gt; link &#x3D; t1 ? t1 : t2; t &#x3D; P; P &#x3D; P-&gt;link; free(t); return P;&#125;int main()&#123; Polynomial P1,P2,Pmulti, Pplus; P1&#x3D;ReadPoly(); P2&#x3D;ReadPoly(); Pmulti&#x3D;Mult(P1,P2); Pplus &#x3D; Add(P1,P2); Print(Pmulti); Print(Pplus); return 0;&#125;&#96;&#96;&#96;&#96;# 02-线性结构4 Pop Sequence （25 分)Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, ..., N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.## Input Specification:Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.## Output Specification:For each pop sequence, print in one line &quot;YES&quot; if it is indeed a possible pop sequence of the stack, or &quot;NO&quot; if not.## Sample Input:5 7 51 2 3 4 5 6 73 2 1 7 5 6 47 6 5 4 3 2 15 6 4 3 7 2 11 7 6 5 4 3 2## Sample Output:YESNONOYESNO## Note1. 栈空的时候不能读里面的数据2. 一行数的输入注意完整性，判断错误后剩余垃圾数据记得处理掉## Code&#96;&#96;&#96;&#96;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main() &#123; int max, num, n; stack &lt;int&gt; s; cin &gt;&gt; max &gt;&gt; num &gt;&gt;n; while(n--) &#123; int j &#x3D; 0; int temp; for(int i &#x3D; 0; i&lt; num; i++) &#123; cin &gt;&gt; temp; if(s.empty()) s.push(++j); while(temp !&#x3D; s.top()) &#123; s.push(++j); if(s.size() &gt; max) &#123; break; &#125; &#125; if(s.size() &lt; 0 || s.size() &gt; max) &#123; &#x2F;&#x2F;保证不影响下一次的检查 for(i++; i &lt; num; i++) cin &gt;&gt; temp; break; &#125; s.pop(); &#125; if(s.size() &#x3D;&#x3D; 0) printf(&quot;YES\\n&quot;); else &#123; printf(&quot;NO\\n&quot;); while(!s.empty()) s.pop(); &#125; &#125; return 0;&#125;&#96;&#96;&#96;&#96;## Code2 #include#includeusing namespace std;int main() { stack s; int num, capcity, testnum; cin &gt;&gt; capcity &gt;&gt; num &gt;&gt; testnum; for(int i = 0; i &lt; testnum; i++){ int n = 1; int cnt = 0; for(int k = 0; k &lt; num; k++) { int temp; cin &gt;&gt; temp; cnt ++; if(s.size() == 0) s.push(n++); while(temp != s.top()){ s.push(n++); if(s.size() &gt; capcity) break; } if(s.size() &gt; capcity){ for(int j = cnt; j &lt; num; j++){ int temp; cin &gt;&gt; temp; } break; } s.pop(); } if(s.size() &gt; capcity) cout &lt;&lt; “NO” &lt;&lt; endl; else cout &lt;&lt; “YES” &lt;&lt; endl; while(s.size() &gt; 0) s.pop(); } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223# 03-树1 树的同构 （25 分)给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190423212923300.png)图1![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190423212933531.png)图2现给定两棵树，请你判断它们是否是同构的。## 输入格式:输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。## 输出格式:如果两棵树是同构的，输出“Yes”，否则输出“No”。## 输入样例1（对应图1）：8A 1 2B 3 4C 5 -D - -E 6 -G 7 -F - -H - -8G - 4B 7 6F - -A 5 1H - -C 0 -D - -E 2 -## 输出样例1:Yes## 输入样例2（对应图2）：8B 5 7F - -A 0 3C 6 -H - -D - -G 4 -E 1 -8D 6 -B 5 -E - -H - -C 0 2G - 3F - -A 1 4## 输出样例2:No## 思路1. 注意到在函数里输入数据的话ifstream cin 不会用2. 判断同构的逻辑不明白其充分性3. 静态链表注意格式 用数组下表代替指针，用数组代替整个链式结构，数组中第i个元素代表其中的内容## Code&#96;&#96;&#96;&#96;#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define Null -1#define Max 10struct Node&#123; char data; int left,right;&#125;T1[Max], T2[Max];int BuildTree(Node T[]) &#123; int num; char data,left,right; cin &gt;&gt; num; vector&lt;int&gt; check(num, 0); if (num )&#123; for(int i &#x3D; 0; i &lt; num; i++) &#123; cin &gt;&gt; data &gt;&gt; left &gt;&gt; right; T[i].data &#x3D; data; if(left &#x3D;&#x3D; &#39;-&#39;) T[i].left &#x3D; Null; else &#123; T[i].left &#x3D; left - &#39;0&#39;; check[T[i].left] &#x3D; 1; &#125; if(right &#x3D;&#x3D; &#39;-&#39;) T[i].right &#x3D; Null; else &#123; T[i].right &#x3D; right - &#39;0&#39;; check[T[i].right] &#x3D; 1; &#125; &#125; int i; for( i &#x3D; 0; i &lt; num; i++)&#123; if(!check[i]) break; &#125; return i; &#125; else return -1; &#125;int Isomophic(int a, int b)&#123; if(a &#x3D;&#x3D; Null &amp;&amp; b &#x3D;&#x3D; Null) return 1; else if(a &#x3D;&#x3D; Null &amp;&amp; b !&#x3D; Null || a !&#x3D; Null &amp;&amp; b &#x3D;&#x3D; Null) return 0; else if(T1[a].data !&#x3D; T2[b].data) return 0; else if(T1[a].left &#x3D;&#x3D; Null &amp;&amp; T2[b].left &#x3D;&#x3D; Null) return Isomophic(T1[a].right, T2[b].right); else if(T1[a].left !&#x3D; Null &amp;&amp; T2[b].left !&#x3D; Null &amp;&amp; T1[T1[a].left].data &#x3D;&#x3D; T2[T2[b].left].data) return Isomophic(T1[a].left, T2[b].left) &amp;&amp; Isomophic(T1[a].right, T2[b].right); else return Isomophic(T1[a].left, T2[b].right) &amp;&amp; Isomophic(T1[a].right, T2[b].left);&#125;int main() &#123;#ifdef _DEBUG ifstream cin(&quot;data.txt&quot;);#endif int A,B; A &#x3D; BuildTree(T1); B &#x3D; BuildTree(T2); Isomophic(A,B) ? cout &lt;&lt; &quot;Yes&quot; : cout &lt;&lt; &quot;No&quot;;#ifdef _DEBUG cin.close( );#endif return 0;&#125;&#96;&#96;&#96;&#96;# 03-树3 Tree Traversals Again (25 分)An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2019042721410458.png)Figure 1## Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: &quot;Push X&quot; where X is the index of the node being pushed onto the stack; or &quot;Pop&quot; meaning to pop one node from the stack.## Output Specification:For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.## Sample Input:6Push 1Push 2Push 3PopPopPush 4PopPopPush 5Push 6PopPop## Sample Output:3 4 2 6 5 1## 思路1. 树的遍历中，除根节点以外其他节点每个结点被访问三次，push一次，pop一次，pop一次因而题目转换成了已知先序和中序求后序2. 具体思路为每次递归求出子树的根节点3. vector &lt;int&gt; 类型的数组 参数从 int a[] 变成 vector &lt; int &gt; a## 例子 pre : 1 2 3 4 5 6 mid : 3 2 4 1 6 5 post: 3 4 2 6 5 1 ## Codes&#96;&#96;&#96;&#96;#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;void getPostOrder(vector&lt;int&gt; pre, int preL, vector&lt;int&gt; mid, int midL,vector&lt;int&gt; &amp;post, int postL, int n) &#x2F;&#x2F;preL midL postl is pointer&#123; if (n &#x3D;&#x3D; 0) return ; if (n &#x3D;&#x3D; 1) &#123; post[postL] &#x3D; pre[preL]; return ; &#125; int root &#x3D; pre[preL]; post[postL + n - 1] &#x3D; root; int i &#x3D; 0; while (i &lt; n) &#123; if (mid[midL + i] &#x3D;&#x3D; root) break; i++; &#125; int L &#x3D; i, nodesnum &#x3D; n - i - 1; getPostOrder(pre, preL + 1, mid, midL, post, postL, L); getPostOrder(pre, preL + L + 1, mid, midL + L + 1, post, postL + L, nodesnum);&#125;int main() &#123; int num; cin &gt;&gt; num; vector &lt;int&gt; pre(num, 0) , mid(num, 0), post(num, 0); stack&lt;int&gt; s; int i &#x3D; 0; for(int cnt &#x3D; 0; i &lt; num; )&#123; string temp ; int tempdata; cin &gt;&gt; temp; if(temp &#x3D;&#x3D; &quot;Push&quot;)&#123; cin &gt;&gt; tempdata; pre[cnt] &#x3D; tempdata; s.push(tempdata); cnt++; &#125; else&#123; mid[i++] &#x3D; s.top(); s.pop(); &#125; &#125; getPostOrder(pre, 0, mid, 0 , post, 0 , num); for(int i &#x3D; 0; i &lt; num; i++) &#123; if(i &lt; num -1) cout &lt;&lt; post[i] &lt;&lt; &quot; &quot;; else cout &lt;&lt; post[i]; &#125; return 0;&#125; &#96;&#96;&#96;&#96;## Code2 dfs #include&lt;bits/stdc++.h&gt;using namespace std;vector res;int num;int a[10010] , intern[10010];int cnt = 0;int ready = 0;void Dfs(int n){ if(ready == 2) return; int tempdata; string temp; cin &gt;&gt; temp; if(temp == “Push”){ cin &gt;&gt; tempdata; a[cnt++] = tempdata; &#125;else &#123; if(cnt == num)&#123; ready ++; &#125; return; &#125; Dfs(n * 2 + 1); Dfs(n * 2 + 2); res.push_back(tempdata); }int main(){ cin &gt;&gt; num; Dfs(0); for(int i = 0; i &lt; num; i++){ if( i== 0) cout &lt;&lt; res[i]; else cout &lt;&lt; “ “ &lt;&lt; res[i]; } return 0;} ``` 04-树4 是否同一棵二叉搜索树 (25 分)给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。 输入格式:输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。 简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。 输出格式:对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。 输入样例:4 23 1 4 23 4 1 23 2 4 12 12 11 20 输出样例:YesNoNo 思路 采用链式结构，设左右孩子、值、flag（用于比较）域。 建搜索树利用递归形式，值大于建在其右子树，小于建在其左子树，若空生成节点并返回 判断方法： 每次搜索经过的节点是否在前面出现过，flag域 为防止判断错误便return， 加设flag标志 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;malloc.h&gt;using namespace std; typedef struct TreeNode *Tree;struct TreeNode&#123; int v; Tree Left, Right; int flag;&#125;;Tree NewNode(int V)&#123; Tree T &#x3D; (Tree)malloc(sizeof(struct TreeNode)); T-&gt;v &#x3D; V; T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL; T-&gt;flag &#x3D; 0; return T;&#125;Tree Insert(Tree T, int V) &#123; if(!T) T &#x3D; NewNode(V); else&#123; if(V &gt; T-&gt;v) T-&gt;Right &#x3D; Insert(T-&gt;Right, V); else T-&gt;Left &#x3D; Insert(T-&gt;Left, V); &#125; return T;&#125;Tree MakeTree(int N) &#123; Tree T; int i, V; cin &gt;&gt; V; T &#x3D; NewNode(V); for(i &#x3D; 1; i &lt; N; i++) &#123; cin &gt;&gt; V; T &#x3D; Insert(T, V); &#125; return T;&#125;int check(Tree T, int V)&#123; if(T-&gt;flag) &#123; if(V &lt; T-&gt;v) return check(T-&gt;Left, V); else if(V &gt; T-&gt;v) return check(T-&gt;Right, V); else return 0; &#125; else&#123; if(V &#x3D;&#x3D; T-&gt;v)&#123; T-&gt;flag &#x3D; 1; return 1; &#125; else return 0; &#125;&#125;int Judge(Tree T, int N) &#123; int i, V; int flag &#x3D; 0; cin &gt;&gt; V; if(V !&#x3D; T-&gt;v) flag &#x3D; 1; else T-&gt;flag &#x3D; 1; for(i &#x3D; 1; i &lt; N; i++) &#123; cin &gt;&gt; V; if((!flag)&amp;&amp;(!check(T, V))) flag &#x3D; 1; &#125; if(flag) return 0; else return 1;&#125;void ResetT(Tree T) &#123; if(T-&gt;Left) ResetT(T-&gt;Left); if(T-&gt;Right) ResetT(T-&gt;Right); T-&gt;flag &#x3D; 0;&#125;void FreeTree(Tree T) &#123; if(T-&gt;Left) FreeTree(T-&gt;Left); if(T-&gt;Right) FreeTree(T-&gt;Right); free(T);&#125;int main() &#123; int N, L, i; Tree T; std::ios::sync_with_stdio(false); cin &gt;&gt; N; while(N) &#123; cin &gt;&gt; L; T &#x3D; MakeTree(N); for(i &#x3D; 0; i &lt; L; i++) &#123; if(Judge(T,N)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt;endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; ResetT(T); &#125; FreeTree(T); cin &gt;&gt; N; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"PAT2","slug":"PAT2","date":"2019-07-03T15:30:43.000Z","updated":"2020-10-06T15:35:27.760Z","comments":true,"path":"2019/07/03/PAT2/","link":"","permalink":"http://example.com/2019/07/03/PAT2/","excerpt":"","text":"1055 The World’s Richest （25 分)Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N people, you must find the M richest people in a given range of their ages. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤10​5​​ ) - the total number of people, and K (≤10​3​​ ) - the number of queries. Then N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in (0, 200]), and the net worth (integer in [−10​6​​ ,10​6​​ ]) of a person. Finally there are K lines of queries, each contains three positive integers: M (≤100) - the maximum number of outputs, and [Amin, Amax] which are the range of ages. All the numbers in a line are separated by a space. Output Specification:For each query, first print in a line Case #X: where X is the query number starting from 1. Then output the M richest people with their ages in the range [Amin, Amax]. Each person’s information occupies a line, in the format Name Age Net_WorthThe outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output None. Sample Input:12 4Zoe_Bill 35 2333Bob_Volk 24 5888Anny_Cin 95 999999Williams 30 -22Cindy 76 76000Alice 18 88888Joe_Mike 32 3222Michael 5 300000Rosemary 40 5888Dobby 24 5888Billy 24 5888Nobody 5 04 15 454 30 354 5 951 45 50Sample Output:Case #1:Alice 18 88888Billy 24 5888Bob_Volk 24 5888Dobby 24 5888Case #2:Joe_Mike 32 3222Zoe_Bill 35 2333Williams 30 -22Case #3:Anny_Cin 95 999999Michael 5 300000Alice 18 88888Cindy 76 76000Case #4:None 超时代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int young, old;struct stu &#123; string name; int age, money;&#125;persons[100010];int cmpbyage (stu a, stu b) &#123; return a.age &lt; b.age;&#125;int cmp (stu a, stu b) &#123; if(a.age &lt;&#x3D; old &amp;&amp; a.age &gt;&#x3D; young &amp;&amp; b.age &lt;&#x3D; old &amp;&amp; b.age &gt;&#x3D; young) return a.money &#x3D;&#x3D; b.money ? a.age &#x3D;&#x3D; b.age ? a.name &lt; b.name : a.age &lt; b.age : a.money &gt; b.money;&#125;int main() &#123; int cnt &#x3D; 0, num, queries; ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; num &gt;&gt; queries; for(int i &#x3D; 0; i &lt; num; i++)&#123; cin &gt;&gt; persons[i].name &gt;&gt; persons[i].age &gt;&gt; persons[i].money; &#125; sort(persons, persons + num, cmpbyage); int rank; for(int i &#x3D; 0; i &lt; queries; i++) &#123; cin &gt;&gt; rank &gt;&gt; young &gt;&gt; old; int startpoint &#x3D; 0, endpoint &#x3D; 0; while(persons[startpoint].age &lt; young &amp;&amp; startpoint &lt; num) startpoint++; while(persons[endpoint].age &lt;&#x3D; old &amp;&amp; endpoint &lt; num) endpoint++; sort(persons+startpoint, persons + endpoint, cmp); cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i+1 &lt;&lt; &#39;:&#39; &lt;&lt; endl; if(startpoint &#x3D;&#x3D; endpoint) &#123; printf(&quot;None\\n&quot;); return 0;&#125;; for(int j &#x3D; 0; j &lt; rank &amp;&amp; startpoint &lt; endpoint ; j++) &#123; cout &lt;&lt; persons[startpoint].name &lt;&lt; &#39; &#39;&lt;&lt; persons[startpoint].age &lt;&lt; &quot; &quot; &lt;&lt; persons[startpoint].money &lt;&lt; endl; startpoint++; &#125; sort(persons, persons + num, cmpbyage); &#125; return 0;&#125; 1075 PAT Judge （25 分)The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT. Input Specification:Each input file contains one test case. For each case, the first line contains 3 positive integers, N (≤10​​​ ), the total number of users, K (≤5), the total number of problems, and M (≤10 ), the total number of submissions. It is then assumed that the user id’s are 5-digit numbers from 00001 to N, and the problem id’s are from 1 to K. The next line contains K positive integers p[i] (i=1, …, K), where p[i] corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format: user_id problem_id partial_score_obtainedwhere partial_score_obtained is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id]]. All the numbers in a line are separated by a space. Output Specification:For each test case, you are supposed to output the ranklist in the following format: rank user_id total_score s[1] … s[K]where rank is calculated according to the total_score, and all the users with the same total_score obtain the same rank; and s[i] is the partial score obtained for the i-th problem. If a user has never submitted a solution for a problem, then “-“ must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted. The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id’s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist. Sample Input:7 4 2020 25 25 3000002 2 1200007 4 1700005 1 1900007 2 2500005 1 2000002 2 200005 1 1500001 1 1800004 3 2500002 2 2500005 3 2200006 4 -100001 2 1800002 1 2000004 1 1500002 4 1800001 3 400001 4 200005 2 -100004 2 0 Sample Output:1 00002 63 20 25 - 182 00005 42 20 0 22 -2 00007 42 - 25 - 172 00001 42 18 18 4 25 00004 40 15 0 25 - 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;struct stu&#123; int id; int score[5]; int sum; int rank;&#125;students[10010]; int c[10000];int num, testnum, subnum;int cmp(stu a, stu b) &#123; if (a.sum &#x3D;&#x3D; b.sum )&#123; int cnta &#x3D; 0,cntb &#x3D; 0; for(int j &#x3D; 0; j &lt; testnum; j++) &#123; if (c[j] &#x3D;&#x3D; a.score[j]) cnta++; if (c[j] &#x3D;&#x3D; b.score[j]) cntb++; &#125; return cnta &#x3D;&#x3D; cntb? a.id &lt; b.id : cnta &gt; cntb; &#125; else return a.sum &gt; b.sum;&#125;void print (stu a) &#123; printf(&quot;%d %05d %d &quot;, a.rank, a.id, a.sum); for(int j &#x3D; 0; j &lt; testnum; j++) &#123; if(j &lt; testnum - 1)&#123; if(a.score[j] &gt;&#x3D; 0) &#123; printf(&quot;%d &quot;, a.score[j]); &#125; else if(a.score[j] &#x3D;&#x3D; -1) printf(&quot;%d &quot;, a.score[j]+1); else printf(&quot;- &quot;); &#125; if(j &#x3D;&#x3D; testnum - 1)&#123; if(a.score[j] &gt;&#x3D; 0) &#123; printf(&quot;%d&quot;, a.score[j]); &#125; else if(a.score[j] &#x3D;&#x3D; -1) printf(&quot;%d&quot;, a.score[j]+1); else printf(&quot;-&quot;); &#125; &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; cin &gt;&gt; num &gt;&gt; testnum &gt;&gt; subnum; for(int j &#x3D; 0; j &lt; testnum; j++) &#123; cin &gt;&gt; c[j] ; &#125; int tempa, tempb, tempc; for(int i &#x3D; 0; i &lt; num; i++) &#123; for(int j &#x3D; 0; j &lt; testnum; j++) &#123; students[i].score[j] &#x3D; -2; &#125; students[i].sum &#x3D; 0; &#125; for (int i &#x3D; 0; i &lt; subnum; i++) &#123; cin &gt;&gt; tempa &gt;&gt; tempb &gt;&gt; tempc; tempa--; if(students[tempa].score[tempb - 1] &lt; tempc)&#123; students[tempa].score[tempb - 1] &#x3D; tempc; students[tempa].id &#x3D; tempa+1; &#125; &#125; for(int i &#x3D; 0; i &lt; num; i++) &#123; for(int j &#x3D; 0; j &lt; testnum; j++) &#123; if(students[i].score[j] &gt; 0) &#123; students[i].sum +&#x3D; students[i].score[j] ; &#125; &#125; &#125; sort(students, students + num, cmp); students[0].rank &#x3D; 1; for(int i &#x3D; 1; i &lt; num; i++) &#123; if(students[i].sum &#x3D;&#x3D; students[i - 1].sum) students[i].rank &#x3D; students[i-1].rank; else students[i].rank &#x3D; i + 1; &#125; for(int i &#x3D; 0; i &lt; num; i++) &#123; if(students[i].sum &gt; 0) print(students[i]); else if(students[i].sum &#x3D;&#x3D; 0) for(int j &#x3D; 0; j &lt; testnum; j++) &#123; if(students[i].score[j] &#x3D;&#x3D; 0) &#123; print(students[i]); break; &#125; &#125; &#125; return 0;&#125; 1080 Graduate Admission （30 分)It is said that in 2013, there were about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure. Each applicant will have to provide two grades: the national entrance exam grade GE, and the interview grade GI. The final grade of an applicant is (GE + GI) / 2. The admission rules are: The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade GE. If still tied, their ranks must be the same.Each applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded.Input Specification: Each input file contains one test case. Each case starts with a line containing three positive integers: N (&lt;=40,000), the total number of applicants; M (&lt;=100), the total number of graduate schools; and K (&lt;=5), the number of choices an applicant may have. In the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively. Then N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s GE and GI, respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M-1, and the applicants are numbered from 0 to N-1. Output Specification: For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly. Sample Input:11 6 32 1 2 2 2 3100 100 0 1 260 60 2 3 5100 90 0 3 490 100 1 2 090 90 5 1 380 90 1 0 280 80 0 1 280 80 0 1 280 70 1 3 270 80 1 2 3100 100 0 2 4Sample Output:0 1035 6 72 8 1 4 代码ps:1.有两个测试点没有通过。。。 2.一个赋值语句的 = 写成了 == 导致查bug 查了半个小时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;struct stu &#123; int rank; int sum,id; int want[5]; int score[2];&#125;students[40000],origin[40000];int cmp(stu a, stu b) &#123; return a.sum &#x3D;&#x3D; b.sum ? a.score[0] &gt; b.score[0] : a.sum &gt; b.sum;&#125;int main() &#123; int save[100][100] &#x3D; &#123;-1&#125;; &#x2F;&#x2F; 录取的学号统计 int ac[100] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 已经录取的人数 int M[100]; &#x2F;&#x2F; 各学校要的人数 int num, Mnum, Knum; cin &gt;&gt; num &gt;&gt; Mnum &gt;&gt; Knum; int i,j; for(i &#x3D; 0; i &lt; Mnum; i++) cin &gt;&gt; M[i]; for(i &#x3D; 0; i&lt; num; i++) &#123; cin &gt;&gt; students[i].score[0] &gt;&gt; students[i].score[1]; students[i].sum &#x3D; students[i].score[0] + students[i].score[1]; students[i].id &#x3D; i; for(j &#x3D; 0; j &lt; Knum; j++) cin &gt;&gt; students[i].want[j]; origin[i] &#x3D; students[i]; &#125; sort(students, students + num, cmp); students[0].rank &#x3D; 1; origin[students[0].id].rank &#x3D; 1; for(i &#x3D; 1; i &lt; num; i++ )&#123; if(students[i].score[0] &#x3D;&#x3D; students[i - 1].score[0] &amp;&amp; students[i].sum &#x3D;&#x3D; students[i - 1].sum) &#123;students[i].rank &#x3D; students[i - 1].rank; origin[students[i].id].rank &#x3D; students[i - 1].rank;&#125; else &#123;students[i].rank &#x3D; i + 1; origin[students[i].id ].rank &#x3D; i + 1;&#125; &#x2F;&#x2F;cout &lt;&lt; students[i].id &#125; &#x2F;&#x2F; for( i &#x3D; 0; i &lt; num; i++)&#123; cout &lt;&lt; origin[i].id &lt;&lt;&quot; &quot;&lt;&lt; origin[i].rank&lt;&lt; endl;&#125;&#x2F;&#x2F; int flag[40000] &#x3D;&#123;0&#125;; for(i &#x3D; 0; i &lt; num; i++) &#123; for(j &#x3D; 0; j &lt; Knum; j++ )&#123; int temp &#x3D; students[i].want[j]; if(ac[temp] &lt; M[temp] &amp;&amp; flag[students[i].id] &#x3D;&#x3D; 0) &#123; save[temp][ac[temp]] &#x3D; students[i].id; ac[temp]++; flag[students[i].id] &#x3D; 1;&#125; else if(ac[temp] &#x3D;&#x3D; M[temp] &amp;&amp; origin[save[temp][ac[temp]-1]].rank &#x3D;&#x3D; students[i].rank &amp;&amp; flag[students[i].id] &#x3D;&#x3D; 0 &amp;&amp; M[temp] !&#x3D; 0 )&#123; save[temp][ac[temp]] &#x3D; students[i].id; ac[temp]++; flag[students[i].id] &#x3D; 1;&#125; &#125; &#125; for(i &#x3D; 0; i &lt; Mnum; i++) sort(save[i], save[i] + ac[i]); for(i &#x3D; 0; i &lt; Mnum; i++) &#123; if(ac[i] &#x3D;&#x3D; 0)&#123;printf(&quot;\\n&quot;); continue;&#125; for(j &#x3D; 0; j &lt; ac[i]; j++)&#123; if(j &lt; ac[i] - 1) printf(&quot;%d &quot;,save[i][j]); else printf(&quot;%d&quot;, save[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 提升1.save可以写成结构体类型，保存更方便2.先确定数组大小，再定义数组3.不用为了tie而再去重新排名，只需记录最后录取同学的序号，通过save找到，判定其总成绩和ge都相等即可 改进的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct stu&#123; int id, ge, gi, sum; vector&lt;int&gt; want;&#125;;bool cmp(stu&amp; a, stu&amp; b) &#123; if (a.sum !&#x3D; b.sum) return a.sum &gt; b.sum; return a.ge &gt; b.ge;&#125;bool cmp2(stu&amp; a, stu&amp; b) &#123; return a.id &lt; b.id;&#125;int main()&#123; int n, m, k, ac[110], cnt[110] &#x3D; &#123;0&#125;; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); vector&lt;stu&gt; stu(n), save[110]; for(int i &#x3D; 0; i &lt; m; i++) scanf(&quot;%d&quot;,&amp;ac[i]); for(int i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;stu[i].ge, &amp;stu[i].gi); stu[i].id &#x3D; i; stu[i].sum &#x3D; stu[i].ge + stu[i].gi; stu[i].want.resize(k); for(int j &#x3D; 0; j &lt; k; j++) scanf(&quot;%d&quot;, &amp;stu[i].want[j]); &#125; sort(stu.begin(), stu.end(), cmp); for(int i &#x3D; 0; i &lt; n; i++) &#123; for(int j &#x3D; 0; j &lt; k; j++) &#123; int temp &#x3D; stu[i].want[j]; &#x2F;&#x2F;想去的学校的序号 int lastindex &#x3D; cnt[temp] - 1; if(cnt[temp] &lt; ac[temp] || (stu[i].sum &#x3D;&#x3D; save[temp][lastindex].sum) &amp;&amp; stu[i].ge &#x3D;&#x3D; save[temp][lastindex].ge) &#123; save[temp].push_back(stu[i]); cnt[temp]++; break; &#125; &#125; &#125; for(int i &#x3D; 0; i &lt; m; i++) &#123; sort(save[i].begin(), save[i].end(), cmp2); for(int j &#x3D; 0; j &lt; cnt[i]; j++) &#123; if(j !&#x3D; 0) printf(&quot; &quot;); printf(&quot;%d&quot;, save[i][j].id); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 1148 Werewolf - Simple Version （20 分)Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: “Player #2 is a werewolf.”;player #2 said: “Player #3 is a human.”;player #3 said: “Player #4 is a werewolf.”;player #4 said: “Player #5 is a human.”; andplayer #5 said: “Player #4 is a human.”.Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder version of this problem: given that there were N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (5≤N≤100). Then N lines follow and the i-th line gives the statement of the i-th player (1≤i≤N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output Specification:If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence – that is, for two sequences A=a[1],…,a[M] and B=b[1],…,b[M], if there exists 0≤k&lt;M such that a[i]=b[i] (i≤k) and a[k+1]&lt;b[k+1], then A is said to be smaller than B. In case there is no solution, simply print No Solution. 12345678910111213141516171819202122232425262728Sample Input 1:5-2+3-4+5+4Sample Output 1:1 4Sample Input 2:6+6+3+1-5-2+4Sample Output 2 (the solution is not unique):1 5Sample Input 3:5-2-3-4-5-1Sample Output 3:No Solution Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;fstream&gt;using namespace std;int main() &#123; int i,j,k,cnt &#x3D; 0; int a[110], b[110] , result[110]; int liar[5], lie, splie; int num;#ifdef _DEBUG ifstream cin(&quot;data.txt&quot;);#endif cin &gt;&gt; num ; for(i &#x3D; 1; i &lt;&#x3D; num; i++) &#123; int temp; cin &gt;&gt; temp; if(temp &lt; 0)&#123; b[i] &#x3D; -1; a[i] &#x3D; -temp;&#125; else&#123; a[i] &#x3D; temp; b[i] &#x3D; 1;&#125; &#125; for(int i &#x3D; 1; i &lt;&#x3D; num; i++)&#123; for(j &#x3D; i + 1; j &lt;&#x3D; num; j++) &#123; for(int m &#x3D; 1; m &lt;&#x3D; num; m++) &#123;result[m] &#x3D; 1; liar[m]&#x3D;0;&#125; result[i] &#x3D; -1; result[j] &#x3D; -1; cnt &#x3D; lie &#x3D; splie &#x3D; 0; for(k &#x3D; 1; k &lt;&#x3D; num; k++)&#123; if(b[k] !&#x3D; result[a[k]])&#123; if(k &#x3D;&#x3D; i || k &#x3D;&#x3D; j)&#123; splie++; liar[cnt++] &#x3D; k;&#125; else &#123; lie++; liar[cnt++] &#x3D; k;&#125; &#125; &#125; if(lie &#x3D;&#x3D; 1 &amp;&amp; splie &#x3D;&#x3D; 1) &#123; cout &lt;&lt; i&lt;&lt; &quot; &quot; &lt;&lt; j; return 0; &#125; &#125; &#125; printf(&quot;No Solution&quot;);#ifdef _DEBUG cin.close();#endif return 0; &#125; Code21234567891011121314151617181920212223242526272829303132#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 1e3 + 10;int a[maxn];int main()&#123; int num, i, j; cin &gt;&gt; num; for(i &#x3D; 1 ; i &lt;&#x3D; num; i++)&#123; cin &gt;&gt; a[i]; &#125; for(i &#x3D; 1 ; i &lt;&#x3D; num; i++)&#123; for(j &#x3D; i + 1; j &lt;&#x3D; num; j++)&#123;&#x2F;&#x2F; i 和j 代表狼 本质上没有顺序的前后 int flagwolf &#x3D; 0, flagcitizen &#x3D; 0, cnt &#x3D; 0;&#x2F;&#x2F; 分别标记是否有狼和民说谎及说谎的人数 vector&lt;int&gt; goodorbad(num + 1, 1); goodorbad[i] &#x3D; - 1; goodorbad[j] &#x3D; - 1; for(int k &#x3D; 1; k &lt;&#x3D; num; k++)&#123; &#x2F;&#x2F; 判断第k个人是否说谎 int temp1 &#x3D; a[k], temp2 &#x3D; goodorbad[abs(a[k])]; if (temp1 * temp2 &lt; 0)&#123; cnt++; if((k &#x3D;&#x3D; i || k &#x3D;&#x3D; j))&#123; if(flagwolf &#x3D;&#x3D; 0 ) flagwolf &#x3D; 1;&#125; else if(flagcitizen &#x3D;&#x3D; 0) flagcitizen &#x3D; 1; &#125; &#125; if(cnt &#x3D;&#x3D; 2 &amp;&amp; flagcitizen &#x3D;&#x3D; 1 &amp;&amp; flagwolf &#x3D;&#x3D; 1)&#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125; 小札 理解错误了 at least one but not all 的意思，导致怎么搞都没搞的出来 用两个数组存取读入的信息这个决定有些不妥，并且再后面判断是否说谎的时候犯了错误: (b[k] != result[a[k]]) 写成了(a[b[k]] != result[a[k]]) 所用时间有些长具体各阶段时间并没有详细划分，不过总时间是一个半小时，难怪真正考试的时候又那么多同学被这道题卡住了。 思路很重要，看完liu神的思路发现 1095 Cars on Campus （30 分)Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period. Input Specification:Each input file contains one test case. Each case starts with two positive integers N (≤10​4​​ ), the number of records, and K (≤8×10​4​​ ) the number of queries. Then N lines follow, each gives a record in the format: plate_number hh:mm:ss statuswhere plate_number is a string of 7 English capital letters or 1-digit numbers; hh:mm:ss represents the time point in a day by hour:minute:second, with the earliest time being 00:00:00 and the latest 23:59:59; and status is either in or out. Note that all times will be within a single day. Each in record is paired with the chronologically next record for the same car provided it is an out record. Any in records that are not paired with an out record are ignored, as are out records not paired with an in record. It is guaranteed that at least one car is well paired in the input, and no car is both in and out at the same moment. Times are recorded using a 24-hour clock. Then K lines of queries follow, each gives a time point in the format hh:mm:ss. Note: the queries are given in ascending order of the times. Output Specification:For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space. Sample Input:16 7JH007BD 18:00:01 inZD00001 11:30:08 outDB8888A 13:00:00 outZA3Q625 23:59:50 outZA133CH 10:23:00 inZD00001 04:09:59 inJH007BD 05:09:59 inZA3Q625 11:42:01 outJH007BD 05:10:33 inZA3Q625 06:30:50 inJH007BD 12:23:42 outZA3Q625 23:55:00 inJH007BD 12:24:23 outZA133CH 17:11:22 outJH007BD 18:07:01 outDB8888A 06:30:50 in05:10:0006:30:5011:00:0012:23:4214:00:0018:00:0023:59:00 Sample Output:1452101JH007BD ZD00001 07:20:09 Analyse 时间存在一个int型数里，方便存取 想找到配对 需整体根据姓名排名局部根据时间排名 进加出减，可以充分利用flag计数 开始时思路不明确，sort错了内容。。。 用map存时间最长的Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct car &#123; char id[10]; int time, flag ;&#125;;bool cmp1(car a, car b) &#123; return strcmp(a.id , b.id) &#x3D;&#x3D; 0 ? a.time &lt; b.time : strcmp(a.id , b.id) &lt; 0 ;&#125;bool cmp2(car a, car b) &#123; return a.time &lt; b.time;&#125;int main() &#123; int n, k, maxtime &#x3D; -1, tempindex &#x3D; 0; scanf(&quot;%d%d\\n&quot;, &amp;n, &amp;k); vector&lt;car&gt; cars(n), valid; for(int i &#x3D; 0; i &lt; n; i++) &#123; char temp[5]; int h, m, s; scanf(&quot;%s %d:%d:%d %s\\n&quot;, cars[i].id, &amp;h, &amp;m, &amp;s, temp); int temptime &#x3D; h * 3600 + m * 60 + s; cars[i].time &#x3D; temptime; cars[i].flag &#x3D; strcmp(temp, &quot;in&quot;) &#x3D;&#x3D; 0 ? 1 : -1; &#125; sort(cars.begin(), cars.end(), cmp1); map&lt;string, int&gt; mapp; for(int i &#x3D; 0; i &lt; n - 1; i++) &#123; if(strcmp(cars[i].id, cars[i+1].id) &#x3D;&#x3D; 0 &amp;&amp; cars[i].flag &#x3D;&#x3D; 1 &amp;&amp; cars[i+1].flag &#x3D;&#x3D; -1) &#123; valid.push_back(cars[i]); valid.push_back(cars[i+1]); mapp[cars[i].id] +&#x3D; (cars[i+1].time - cars[i].time); if(maxtime &lt; mapp[cars[i].id]) &#123; maxtime &#x3D; mapp[cars[i].id]; &#125; &#125; &#125; sort(valid.begin(), valid.end(), cmp2); vector&lt;int&gt; cnt(n); for(int i &#x3D; 0; i &lt; valid.size(); i++) &#123; if(i &#x3D;&#x3D; 0) cnt[i] +&#x3D; valid[i].flag; else cnt[i] &#x3D; cnt[i - 1] + valid[i].flag; &#125; for(int i &#x3D; 0; i &lt; k; i++) &#123; int h, m, s; scanf(&quot;%d:%d:%d&quot;, &amp;h, &amp;m, &amp;s); int temptime &#x3D; h * 3600 + m * 60 + s; int j; for(j &#x3D; tempindex; j &lt; valid.size(); j++) &#123; if(valid[j].time &gt; temptime) &#123; printf(&quot;%d\\n&quot;, cnt[j - 1]); break; &#125; else if(j &#x3D;&#x3D; valid.size() - 1) &#123; printf(&quot;%d\\n&quot;, cnt[j]); &#125; &#125; tempindex &#x3D; j; &#125; for(map&lt;string, int&gt;::iterator it &#x3D; mapp.begin(); it !&#x3D; mapp.end(); it++) &#123; if(it-&gt;second &#x3D;&#x3D; maxtime) printf(&quot;%s &quot;, it-&gt;first.c_str()); &#125; printf(&quot;%02d:%02d:%02d&quot;, maxtime &#x2F; 3600, (maxtime % 3600) &#x2F; 60, maxtime % 60); return 0;&#125; Aborted Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;fstream&gt;#include&lt;cstdio&gt;using namespace std;struct car &#123; char name[10]; int time; int state; int sum;&#125;;int cmp1(car a, car b) &#123; return strcmp(a.name , b.name) &#x3D;&#x3D; 0 ? a.time &lt; b.time : strcmp(a.name , b.name) &lt; 0 ;&#125;int cmp2(car a, car b) &#123; return a.time &lt; b.time;&#125;int main() &#123; int num,queries; int k&#x3D;0; cin &gt;&gt; num &gt;&gt; queries; vector &lt;car&gt; cars(num); vector &lt;car&gt; valid(num); for(int i &#x3D; 0; i &lt; num; i++) &#123; int temp1, temp2, temp3; char tempc[10]; scanf(&quot;%s %d:%d:%d %s&quot;, &amp;cars[i].name, &amp;temp1, &amp;temp2, &amp;temp3,tempc); cars[i].sum &#x3D; 0; cars[i].time &#x3D; temp1 * 3600 + temp2 * 60 + temp3; strcmp(tempc,&quot;in&quot;) &#x3D;&#x3D; 0 ? cars[i].state &#x3D; 1 : cars[i].state &#x3D; 0; &#125; sort(cars.begin(), cars.end(), cmp1); int temp &#x3D; cars[0].state; int point &#x3D; 0; int cnt &#x3D; 0; int mem &#x3D; 0; for(int i &#x3D; 1; i &lt; num; i++)&#123; temp &#x3D; cars[i-1].state; if(strcmp(cars[i].name , cars[i-1].name) &#x3D;&#x3D; 0)&#123; if(temp + cars[i].state &#x3D;&#x3D; 2) point &#x3D; i; else if(temp &#x3D;&#x3D; 1 &amp;&amp; cars[i].state &#x3D;&#x3D; 0) &#123; valid[cnt++] &#x3D; cars[i-1]; valid[cnt] &#x3D; cars[i]; valid[cnt].sum &#x3D; cars[i].time - cars[i-1].time + mem; mem &#x3D;valid[cnt++].sum ; &#125; &#125; else mem &#x3D; 0; &#125; char maxname[5][10]; int max &#x3D; 0; for(int j &#x3D; 0; j &lt; cnt - 1; j++) &#123; if(valid[j].sum &gt; max) &#123; k&#x3D;0; max &#x3D; valid[j].sum; strcpy(maxname[k], valid[j].name); &#125; else if(valid[j].sum &#x3D;&#x3D; max) &#123; if(j !&#x3D;0) strcpy(maxname[++k],valid[j].name); else strcpy(maxname[k],valid[j].name); &#125;&#x2F;&#x2F; printf(&quot;%s &quot; , maxname[0]); &#125; sort(valid.begin(), valid.end(), cmp2); for(int i &#x3D; 0; i &lt; cnt - 1; i++) &#123;&#x2F;&#x2F; printf(&quot;%s &quot; , valid[i].name); printf(&quot;%d:%d:%d&quot;, valid[i].time&#x2F;3600, ( valid[i].time&#x2F;60)%60, valid[i].time%60); printf(&quot; %d\\n&quot;, valid[i].state); &#125; while(1); &#x2F;&#x2F;*&#x2F; for(int i &#x3D; 0; i &lt; queries; i++) &#123; int temp1, temp2, temp3, time; int empty &#x3D; 0; scanf(&quot;%d:%d:%d&quot;, &amp;temp1, &amp;temp2, &amp;temp3); time &#x3D; temp1 * 3600 + temp2 * 60 + temp3; for(int j &#x3D; 0; valid[j].time &lt; time &amp;&amp; j &lt; cnt - 1; j++) &#123; if(valid[j].state &#x3D;&#x3D; 1) empty ++; else empty -- ; &#125; if(empty &gt;&#x3D; 0) printf(&quot;%d\\n&quot;, empty ); &#125; for(int i &#x3D; 0; i &lt; k; i++) &#123; printf(&quot;%s &quot; , maxname[i]); &#125; printf(&quot;%02d:%02d:%02d&quot;, max&#x2F;3600, (max&#x2F;60)%60,max%60); return 0;&#125;","categories":[],"tags":[]},{"title":"PAT1","slug":"PAT","date":"2019-06-16T08:23:16.000Z","updated":"2020-10-06T15:35:33.846Z","comments":true,"path":"2019/06/16/PAT/","link":"","permalink":"http://example.com/2019/06/16/PAT/","excerpt":"","text":"1009多项式的乘法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define NULL 0typedef struct PolyNode *Polynomial;int length &#x3D; 0;struct PolyNode &#123; double coef; int expon; Polynomial link;&#125;;void Attach(double c, int e, Polynomial* pRear)&#123; Polynomial P; P &#x3D; (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef &#x3D; c; P-&gt;expon &#x3D; e; P-&gt;link &#x3D; NULL; (*pRear)-&gt;link &#x3D; P; *pRear &#x3D; P;&#125;Polynomial ReadPoly (void)&#123; Polynomial P,Rear,t; int n; double c; int e; scanf(&quot;%d&quot;, &amp;n); P&#x3D;(Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link&#x3D;NULL; Rear&#x3D;P; while(n--) &#123; scanf(&quot;%d %lf&quot;, &amp;e, &amp;c); Attach(c, e, &amp;Rear); &#125; t&#x3D;P; P&#x3D;P-&gt;link; free(t); return P;&#125;Polynomial Mult( Polynomial P1, Polynomial P2 )&#123; Polynomial P, Rear, t1, t2, t; double c; int e; if (!P1 || !P2) return NULL; t1 &#x3D; P1; t2 &#x3D; P2; P &#x3D; (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link &#x3D; NULL; Rear &#x3D; P; while (t2) &#123; &#x2F;* 先用P1的第1项乘以P2，得到P *&#x2F; Attach(t1-&gt;coef*t2-&gt;coef, t1-&gt;expon+t2-&gt;expon, &amp;Rear); t2 &#x3D; t2-&gt;link; &#125; t1 &#x3D; t1-&gt;link; while (t1) &#123; t2 &#x3D; P2; Rear &#x3D; P; while (t2) &#123; e &#x3D; t1-&gt;expon + t2-&gt;expon; c &#x3D; t1-&gt;coef * t2-&gt;coef; while (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) Rear &#x3D; Rear-&gt;link; if (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &#x3D;&#x3D; e) &#123; if (Rear-&gt;link-&gt;coef + c) Rear-&gt;link-&gt;coef +&#x3D; c; else &#123; t &#x3D; Rear-&gt;link; Rear-&gt;link &#x3D; t-&gt;link; free(t); &#125; &#125; else &#123; t &#x3D; (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef &#x3D; c; t-&gt;expon &#x3D; e; t-&gt;link &#x3D; Rear-&gt;link; Rear-&gt;link &#x3D; t; Rear &#x3D; Rear-&gt;link; &#125; t2 &#x3D; t2-&gt;link; &#125; t1 &#x3D; t1-&gt;link; &#125; t2 &#x3D; P; P &#x3D; P-&gt;link; free(t2); return P;&#125;void Pint(Polynomial P)&#123; int flag &#x3D; 0; if (!P) &#123; printf(&quot;0 0\\n&quot;); return;&#125; while(P)&#123; if(!flag) flag &#x3D; 1; else&#123; printf(&quot; &quot;); &#125; printf(&quot;%d %.1f&quot;, P-&gt;expon ,P-&gt;coef); P &#x3D; P-&gt;link; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; Polynomial P1,P2,P; P1 &#x3D; ReadPoly(); P2 &#x3D; ReadPoly(); &#x2F;&#x2F;Pint(P1); &#x2F;&#x2F;Pint(P2); P &#x3D; Mult(P1,P2); Pint(P); return 0;&#125; 1024科学计数法123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int main()&#123; char a[10010]; int i,j,k; int jie=0; gets(a); if(a[0] == &#x27;-&#x27;) printf(&quot;-&quot;); for(i = 1;a[i] != &#x27;E&#x27;; i++); for(j = i+2; a[j] != &#x27;\\0&#x27;; j++) jie=jie*10+a[j]-&#x27;0&#x27;; if(a[i+1] == &#x27;+&#x27;)&#123; for(j=1;j &lt; i; j++)&#123; if(a[j] == &#x27;.&#x27;) continue; printf(&quot;%c&quot;, a[j]); if(j == jie+2 &amp;&amp; jie &lt; i - 3 ) printf(&quot;.&quot;); &#125; if(jie &gt; i-3) for(j = 0; j &lt; jie-i+3;j++) printf(&quot;0&quot;); &#125; else&#123; printf(&quot;0.&quot;); for(j = 0; j &lt; jie-1; j++) printf(&quot;0&quot;); for(j=1;j&lt;i;j++)&#123; if(a[j] == &#x27;.&#x27;) continue; printf(&quot;%c&quot;, a[j]); &#125; &#125; return 0;&#125; 1048 数字加密本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式：输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式：在一行中输出加密后的结果。 输入样例：1234567 368782971输出样例：3695Q8118 自己的思路没有用到数组的反转，硬刚。错误点很多，耗时长 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int main()&#123; int temp,i,j,flag&#x3D;0, lengtha,lengthb,t; char a[250], b[252], c[3] &#x3D; &#123;&#39;J&#39;,&#39;Q&#39;,&#39;K&#39;&#125;, output[250]; scanf(&quot;%s&quot;, a); scanf(&quot;%s&quot;, b); lengtha &#x3D; strlen(a); lengthb &#x3D; strlen(b); if(lengtha &lt; lengthb)&#123; for(i &#x3D; lengtha - 1;i &gt;&#x3D; 0; i--) a[i+lengthb-lengtha] &#x3D; a[i]; t&#x3D;lengthb-1; for(i &#x3D; 0; i&lt;lengthb - lengtha;i++) a[i]&#x3D;&#39;0&#39;; &#125; else if(lengthb &lt; lengtha)&#123; for(i &#x3D; lengthb - 1;i &gt;&#x3D; 0; i--) b[i-lengthb+lengtha] &#x3D; b[i]; t&#x3D;lengtha-1; for(i &#x3D; 0; i&lt;lengtha - lengthb;i++) b[i]&#x3D;&#39;0&#39;; &#125; else t&#x3D;lengtha-1; for(i &#x3D; t;i &gt;&#x3D; 0;i--)&#123; if(!flag) flag&#x3D;1; else flag &#x3D; 0; if(flag)&#123; temp&#x3D;a[i] + b[i] - &#39;0&#39;-&#39;0&#39;; if(temp &lt; 10 || temp &gt;&#x3D; 13) output[i] &#x3D; temp % 13 + &#39;0&#39;; else output[i] &#x3D; c[temp - 10]; &#125; else&#123; output[i] &#x3D; (b[i] - a[i] + 10) % 10 +&#39;0&#39;; &#125; &#125; for(i&#x3D;0;i &lt; t+1;i++) printf(&quot;%c&quot;, output[i]);&#125; 答案12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn &#x3D; 110;char A[maxn], B[maxn], ans[maxn] &#x3D; &#123;0&#125;; void reversing(char s[]) &#123; int len &#x3D; strlen(s); for(int i &#x3D; 0; i &lt; len &#x2F; 2; i++) &#123; int temp &#x3D; s[i]; s[i] &#x3D; s[len - 1 - i]; s[len - 1 - i] &#x3D; temp; &#125;&#125; int main() &#123; scanf(&quot;%s %s&quot;, A, B); reversing(A); reversing(B); int lenA &#x3D; strlen(A); int lenB &#x3D; strlen(B); int len &#x3D; lenA &gt; lenB ? lenA : lenB; for(int i &#x3D; 0; i &lt; len; i++) &#123; int numA &#x3D; i &lt; lenA ? A[i] - &#39;0&#39; : 0; int numB &#x3D; i &lt; lenB ? B[i] - &#39;0&#39; ：0; if(i % 2 &#x3D;&#x3D; 0) &#123; int temp &#x3D; (numB + numA) % 13; if(temp &#x3D;&#x3D; 10) ans[i] &#x3D; &#39;J&#39;; else if(temp &#x3D;&#x3D; 11) ans[i] &#x3D; &#39;Q&#39;; else if(temp &#x3D;&#x3D; 12) ans[i] &#x3D; &#39;K&#39; else ans[i] &#x3D; temp + &#39;0&#39;; &#125; else&#123; int temp &#x3D; numB - numA; if(temp &lt; 0) temp +&#x3D; 10; ans[i] &#x3D; temp &#x3D; &#39;0&#39;; &#125; &#125; revers(ans); puts(ans); return 0;&#125; 1077 Kuchiguse （20 分)The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality: Itai nyan~ (It hurts, nyan~) Ninjin wa iyada nyan~ (I hate carrots, nyan~) Now given a few lines spoken by the same character, can you find her Kuchiguse? Input Specification:Each input file contains one test case. For each case, the first line is an integer N (2≤N≤100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive. Output Specification:For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write nai. Sample Input 1:3Itai nyan~Ninjin wa iyadanyan~uhhh nyan~Sample Output 1:nyan~Sample Input 2:3Itai!Ninjinnwaiyada T_TT_TSample Output 2:nai 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;string.h&gt;char a[10000][100000];int n;void traverse(char s[]) &#123; int temp; int len &#x3D; strlen(s); for(int i &#x3D; 0; i &lt; len&#x2F;2; i++)&#123; temp &#x3D; s[i]; s[i] &#x3D; s[len - i -1]; s[len - i - 1] &#x3D; temp; &#125;&#125;int min(int n) &#123; int min &#x3D; 1000; int temp; for(int i &#x3D; 0; i &lt; n; i++) &#123; temp &#x3D; strlen(a[i]); if(temp &lt; min) min &#x3D; temp; &#125; return min;&#125;int main()&#123; int flag,j,i; int minlen, same &#x3D; 0; scanf(&quot;%d&quot;, &amp;n); if(n &#x3D;&#x3D; 0) &#123; printf(&quot;nai&quot;); return 0;&#125; getchar(); for(i &#x3D; 0; i &lt; n; i++) &#123; gets(a[i]); &#x2F;&#x2F;printf(&quot;%dfjakfa0\\n&quot;, i); traverse(a[i]); &#x2F;&#x2F;puts(a[i]); &#125; &#x2F;&#x2F;while(1); minlen &#x3D; min(n); for(i &#x3D; 0; i &lt; minlen; i++) &#123; flag &#x3D; 0; char c &#x3D; a[0][i]; for(j &#x3D; 0; j &lt; n; j++) &#123; if(c !&#x3D; a[j][i])&#123; flag &#x3D; 1; break;&#125; &#125; if(!flag) same &#x3D; i+1; else break;&#x2F;&#x2F;这句话没加，导致查第三个点查了好久！！！（如果没加，后面又有都相等的就覆盖掉了） &#125; if(same &#x3D;&#x3D; 0)&#123; printf(&quot;nai&quot;); return 0; &#125; for(i &#x3D; same; i &gt; 0; i--)&#123; printf(&quot;%c&quot;, a[0][i-1]); &#125;&#125; 1082 Read Number in Chinese （25 分)Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai. Input Specification:Each input file contains one test case, which gives an integer with no more than 9 digits. Output Specification:For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 1:-123456789 Sample Output 1:Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 2:100800 Sample Output 2:yi Shi Wan ling ba Bai 自己的思路：整体上是一个数字（traverse）后跟着一个位（chinese）但要处理以下特殊情况1.负数2.末尾的处理 2.1 普通末尾2.2 末尾为零 3.零的处理 这样的思路还是枚举法，很容易少考虑到一些情况，如果实战真用这种法方，那心态估计早就崩了吧。。。。。。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char a[11]; char traverse[10][10] &#x3D; &#123;&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;&#125;; char chinese[10][10] &#x3D; &#123;&quot;Yi&quot;, &quot;Qian&quot;, &quot;Bai&quot;, &quot;Shi&quot;, &quot;Wan&quot;, &quot;Qian&quot;, &quot;Bai&quot;, &quot;Shi&quot;&#125;; int i,j,k,n; int lastone; int specialflag &#x3D; 0; scanf(&quot;%s&quot;,a); n &#x3D; strlen(a); if(a[0] &#x3D;&#x3D; &#39;-&#39;) &#123; printf(&quot;Fu &quot;); i &#x3D; 1; &#125; else i &#x3D; 0; if(n &gt;&#x3D; 9 )&#123; for(k &#x3D; i + 1, j &#x3D; k+4; k &lt; j; k++) if(a[k] !&#x3D; &#39;0&#39;) break; else specialflag ++; &#125; lastone &#x3D; n-1; while(a[lastone] &#x3D;&#x3D; &#39;0&#39;)&#123;lastone--;&#125; while(a[i] &#x3D;&#x3D; &#39;0&#39;) i++; for(; i &lt; n - 1; i++) &#123; if(a[i] !&#x3D; &#39;0&#39; || (a[i + 1] !&#x3D; &#39;0&#39; &amp;&amp; a[i] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; i &lt; n - 1 &amp;&amp; strcmp(chinese[i + 9 - n] , &quot;Wan&quot;) !&#x3D; 0)) printf(&quot;%s &quot;, traverse[a[i] - &#39;0&#39;]); &#x2F;&#x2F; &#123; printf(&quot;ling &quot;); continue;&#125; if(((a[i] !&#x3D; &#39;0&#39;)||(a[i] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; strcmp(chinese[i + 9 - n] , &quot;Wan&quot;) &#x3D;&#x3D; 0 &amp;&amp; specialflag !&#x3D; 4 )))&#123; if(i &lt; lastone ) printf(&quot;%s &quot;, chinese[i + 9 - n]); else &#123; if(i + 9 - n &lt; 4 &amp;&amp; specialflag !&#x3D; 4) printf(&quot;%s &quot;, chinese[i + 9 - n]); else printf(&quot;%s&quot;, chinese[i + 9 - n]); &#125; &#125; &#125; if(a[i] !&#x3D; &#39;0&#39;) printf(&quot;%s&quot;, traverse[a[i] - &#39;0&#39;]); &#x2F;&#x2F;printf(&quot;ajdkfl&quot;);&#125; 未完 测试点三一直没过 感觉就像熟悉的大二freescale式的if else 代码 好吧解决掉了，忘记处理单零的情况，哭晕在厕所。。。。。。。 1015 德才论 （25 分)宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式：输入第一行给出 3 个正整数，分别为：N（≤10​5​​ ），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式：输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例：14 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60输出样例：1210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90问题：利用冒泡排序，会发现两个测试点超时解决办法：利用c++的sort函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;typedef struct stu stu;struct stu &#123; int id; int d; int c;&#125; yi[10000], er[10000], san[10000], si[10000], students[100010];void mySort(stu(&amp;a)[10000], int n) &#123; int i, j, k; stu b; stu temp; for (i &#x3D; 0; i &lt; n; i++) &#123; for (j &#x3D; 0 ; j &lt; n - i - 1; j++) &#123; if (a[j].d + a[j].c &lt; a[j+ 1].d + a[j + 1].c) &#123; temp &#x3D; a[j]; a[j] &#x3D; a[j + 1]; a[j + 1] &#x3D; temp; &#125; else if (a[j].d &#x3D;&#x3D; a[j + 1].d &amp;&amp; a[j].c &#x3D;&#x3D; a[j + 1].c) &#123; if (a[j].id &gt; a[j + 1].id) &#123; temp &#x3D; a[j]; a[j] &#x3D; a[j + 1]; a[j + 1] &#x3D; temp; &#125; &#125; else if (a[j].d + a[j].c &#x3D;&#x3D; a[j + 1].c + a[j + 1].d) &#123; if (a[j].d &lt; a[j + 1].d) &#123; temp &#x3D; a[j]; a[j] &#x3D; a[j + 1]; a[j + 1] &#x3D; temp; &#125; &#125; &#125; &#125;&#125;int main() &#123; int i, j, k, n; int L, H; int a, b, c, e; a &#x3D; b &#x3D; c &#x3D; e &#x3D; 0; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%d %d&quot;, &amp;L, &amp;H); for (i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d %d %d&quot;, &amp;students[i].id, &amp;students[i].d, &amp;students[i].c); if (students[i].d &gt;&#x3D; L &amp;&amp; students[i].c &gt;&#x3D; L) &#123; if (students[i].d &gt;&#x3D; H &amp;&amp; students[i].c &gt;&#x3D; H) &#123; yi[a++] &#x3D; students[i]; &#125; else if (students[i].d &gt;&#x3D; H &amp;&amp; students[i].c &lt; H) &#123; er[b++] &#x3D; students[i]; &#125; else if (students[i].d &lt; H &amp;&amp; students[i].c &lt; H &amp;&amp; students[i].d &gt;&#x3D; students[i].c) &#123; san[c++] &#x3D; students[i]; &#125; else if (students[i].d &gt;&#x3D; L &amp;&amp; students[i].c &gt;&#x3D; L) &#123; si[e++] &#x3D; students[i]; &#125; &#125; &#125; mySort(yi, a); mySort(er, b); mySort(san, c); mySort(si, e); printf(&quot;%d\\n&quot;, a + b + c + e); for (i &#x3D; 0; i &lt; a; i++) printf(&quot;%d %d %d\\n&quot;, yi[i].id, yi[i].d, yi[i].c); for (i &#x3D; 0; i &lt; b; i++) printf(&quot;%d %d %d\\n&quot;, er[i].id, er[i].d, er[i].c); for (i &#x3D; 0; i &lt; c; i++) printf(&quot;%d %d %d\\n&quot;, san[i].id, san[i].d, san[i].c); for (i &#x3D; 0; i &lt; e; i++) printf(&quot;%d %d %d\\n&quot;, si[i].id, si[i].d, si[i].c);&#125; 正确答案： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct Student &#123; char id[10]; int de, cai, sum; int flag;&#125;stu[100010];bool cmp(Student a, Student b) &#123; if (a.flag !&#x3D; b.flag) return a.flag &lt; b.flag; else if (a.sum !&#x3D; b.sum) return a.sum &gt; b.sum; else if (a.de !&#x3D; b.de) return a.de &gt; b.de; else return strcmp(a.id, b.id) &lt; 0;&#125;int main() &#123; int n, L, H; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;L, &amp;H); int m &#x3D; n; for (int i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%s%d%d&quot;, &amp;stu[i].id, &amp;stu[i].de, &amp;stu[i].cai); stu[i].sum &#x3D; stu[i].de + stu[i].cai; if (stu[i].de &lt; L || stu[i].cai &lt; L) &#123; stu[i].flag &#x3D; 5; m--; &#125; else if (stu[i].de &gt;&#x3D; H &amp;&amp; stu[i].cai &gt;&#x3D; H) stu[i].flag &#x3D; 1; else if (stu[i].de &gt;&#x3D; H &amp;&amp; stu[i].cai &lt; H) stu[i].flag &#x3D; 2; else if (stu[i].de &gt;&#x3D; stu[i].cai) stu[i].flag &#x3D; 3; else stu[i].flag &#x3D; 4; &#125; sort(stu, stu + n, cmp); printf(&quot;%d\\n&quot;, m); for (int i &#x3D; 0; i &lt; m; i++) &#123; printf(&quot;%s %d %d\\n&quot;, stu[i].id, stu[i].de, stu[i].cai); &#125; return 0;&#125; 1025 PAT Ranking （25 分)Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input Specification:Each input file contains one test case. For each case, the first line contains a positive number N (≤100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (≤300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format: registration_number final_rank location_number local_rankThe locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input:251234567890001 951234567890005 1001234567890003 951234567890002 771234567890004 8541234567890013 651234567890011 251234567890014 1001234567890012 85Sample Output:91234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 出现的问题1.成绩相等时的排名忘记利用人的个数2.local的排名误用了总人数i，查了好个半天 -_- 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef struct stu stu;struct stu &#123; char id[20]; int score; int place;&#125;local[100][310], sum[40000];bool cmp(stu a, stu b) &#123; if (a.score &#x3D;&#x3D; b.score) return (strcmp(a.id, b.id) &lt; 0); else return a.score &gt; b.score;&#125;int main() &#123; int localrank[100010] &#x3D; &#123;0&#125;, finalrank &#x3D; 1; int i, j, k &#x3D; 0, n[100010], placenum; int sumnum &#x3D; 0; scanf(&quot;%d&quot;, &amp;placenum); for (i &#x3D; 0; i &lt; placenum; i++) &#123; scanf(&quot;%d&quot;, &amp;n[i]); sumnum +&#x3D; n[i]; for (j &#x3D; 0; j &lt; n[i]; j++) &#123; scanf(&quot;%s %d&quot;, &amp;local[i][j].id, &amp;local[i][j].score); local[i][j].place &#x3D; i ; sum[k++] &#x3D; local[i][j]; &#125; sort(local[i], local[i] + n[i], cmp); &#x2F;&#x2F;for (j &#x3D; 0; j &lt; n[i]; j++) printf(&quot;%s %d\\n&quot;, local[i][j].id, local[i][j].score); &#125; &#x2F;&#x2F; (1); sort(sum, sum + sumnum, cmp); printf(&quot;%d\\n&quot;, sumnum); int localnum[10010] &#x3D; &#123; 0 &#125;; for (i &#x3D; 0; i &lt; sumnum - 1; i++) &#123; localnum[sum[i].place]++; printf(&quot;%s %d %d %d\\n&quot;, sum[i].id, finalrank, sum[i].place + 1, localrank[sum[i].place] + 1 ); if (sum[i].score !&#x3D; sum[i + 1].score ) finalrank &#x3D; 2 + i; if (local[sum[i].place][localnum[sum[i].place]-1].score !&#x3D; local[sum[i].place][localnum[sum[i].place]].score) localrank[sum[i].place] &#x3D; localnum[sum[i].place]; &#125; printf(&quot;%s %d %d %d\\n&quot;, sum[i].id, finalrank, sum[i].place + 1, localrank[sum[i].place] + 1);&#125; 1016 Phone Bills （25 分)A long-distance telephone company charges its customers by the following rules: Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records. Input Specification:Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records. The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day. The next line contains a positive number N (≤1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (mm:dd:hh:mm), and the word on-line or off-line. For each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock. Output Specification:For each test case, you must print a phone bill for each customer. Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:hh:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample. Sample Input:10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-lineSample Output:CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80 解刚刚看完c++的stl使用和柳神的博客，看到此题属于不常考类型，自己没有好的思路，所以阅读了柳神的代码，以熟悉各种容器的使用 注意 the time and date (mm:dd:hh:mm) --- time的意思应该是month 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include&lt;string&gt;using namespace std;struct node &#123; string name; int status, month, time, day, hour, minute;&#125;;bool cmp(node a, node b) &#123; return a.name !&#x3D; b.name ? a.name &lt; b.name : a.time &lt; b.time; &#x2F;&#x2F;先按照姓名排序，再按照时间的先后顺序排列&#125;double billFromZero(node call, int *rate) &#123; double total &#x3D; rate[call.hour] * call.minute + rate[24] * 60 * call.day; &#x2F;&#x2F;计算多少钱 for (int i &#x3D; 0; i &lt; call.hour; i++) total +&#x3D; rate[i] * 60; return total &#x2F; 100.0;&#125;int main() &#123; int rate[25] &#x3D; &#123;0&#125;, n; for (int i &#x3D; 0; i &lt; 24; i++) &#123; scanf(&quot;%d&quot;, &amp;rate[i]); rate[24] +&#x3D; rate[i]; &#x2F;&#x2F;数组最后一个位置存放24小时利率之和 &#125; scanf(&quot;%d&quot;, &amp;n); vector&lt;node&gt; data(n); &#x2F;&#x2F;体现动态数组的优点！！！ for (int i &#x3D; 0; i &lt; n; i++) &#123; cin &gt;&gt; data[i].name; scanf(&quot;%d:%d:%d:%d&quot;, &amp;data[i].month, &amp;data[i].day, &amp;data[i].hour, &amp;data[i].minute); string temp; cin &gt;&gt; temp; data[i].status &#x3D; (temp &#x3D;&#x3D; &quot;on-line&quot;) ? 1 : 0; data[i].time &#x3D; data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute; &#x2F;&#x2F;时间转换为一个数 &#125; sort(data.begin(), data.end(), cmp); map&lt;string, vector&lt;node&gt; &gt; custom; &#x2F;&#x2F;string,结构体 类型的键值对 custom（本身也是一个动态数组） for (int i &#x3D; 1; i &lt; n; i++) &#123; if (data[i].name &#x3D;&#x3D; data[i - 1].name &amp;&amp; data[i - 1].status &#x3D;&#x3D; 1 &amp;&amp; data[i].status &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;，前后两个名字相同且前面的状态为on-line后面一个的状态为off-line custom[data[i - 1].name].push_back(data[i - 1]); &#x2F;&#x2F;custom记录所有的有效数据 custom[data[i].name].push_back(data[i]); &#125; &#125; for (auto it : custom) &#123;&#x2F;&#x2F; 用指针it 遍历string,结构体 类型的容器custom vector&lt;node&gt; temp &#x3D; it.second; &#x2F;&#x2F;取值 cout &lt;&lt; it.first; &#x2F;&#x2F;取键 printf(&quot; %02d\\n&quot;, temp[0].month); double total &#x3D; 0.0; for (int i &#x3D; 1; i &lt; temp.size(); i +&#x3D; 2) &#123; double t &#x3D; billFromZero(temp[i], rate) - billFromZero(temp[i - 1], rate); printf(&quot;%02d:%02d:%02d %02d:%02d:%02d %d $%.2f\\n&quot;, temp[i - 1].day, temp[i - 1].hour, temp[i - 1].minute, temp[i].day, temp[i].hour, temp[i].minute, temp[i].time - temp[i - 1].time, t); total +&#x3D; t; &#125; printf(&quot;Total amount: $%.2f\\n&quot;, total); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"NXP","slug":"nxp","date":"2018-09-06T07:10:16.000Z","updated":"2020-10-06T15:11:23.881Z","comments":true,"path":"2018/09/06/nxp/","link":"","permalink":"http://example.com/2018/09/06/nxp/","excerpt":"","text":"2018年度总结札记可能是第一次认真的在年末写这种东西，之前不想写的原因是总结是随时随地的，不应该都挤在年末的时候。然而今年想写的原因一个是因为这个网站吧，另一个便是感觉自己好像真的认清自己了，认清了这个不敢直视的自己。 流水线2018.1.1-2018-7.26这段时间正是准备省赛的是侯，当时的想法已经在之前记录过： ——这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。 记得第一次偷偷地在浙大智能车培训ppt上看到这句话的时候，不解为何要单独摘出这句话。如今一切既定，虽然不想承认，但恍惚发现这碗毒鸡汤正是准备给自己。 智能车，与其说他是一门竞赛，倒不如说是一种生活。第一次接触它的时候，是在去年盛夏的一个傍晚。看到儿时四驱兄弟的现场真人版，不自觉地浮想联翩。但开始经历暑期培训之后，才知这生活并不好受。一来便发现自己与其他同学水平之间的差距大到无法与他们交流，当我的呼吸灯还没正常闪烁时他们已经能用链表玩起了贪吃蛇，当我还在研究怎么让数据传回电脑时，他们已经调稳了传回的波形甚至加了我至今不明原理的滤波。几度想过放弃但所幸有学长一旁鼓励 。 半坚持半发呆地熬过了任务最繁杂的时期。晚上放松时，在寝室偷偷地刷完了《鸡毛飞上天》。大二上学期，记得是最燃的一个学期。那时一直都很幸运，因为付出的汗水都得到了回报。C+的图像一遍一遍的改，速度也会一点一点的提升，有好几次在凌晨对望六教五楼的考研教室，知道熬夜不好，但那时内心还是很开心入梦时耳边是《火影忍者》的主题曲。 寒假的时候，脑子里还在想着如何用好编码器再提点速，却被告知更换了组别。当时内心并不想调直立，因为真的只是单纯觉得四个轮子更帅些，更像儿时的四驱兄弟。不过被换到的是当时我们觉得最好的组别，战斗力不减反增。延续着上学期良好的状态，充实的过活（不过可能是假期的原因，竟刷完了高圆圆的几乎所有的影视剧）可能是寒假用力过猛，大二下学期的开学丝毫没有仪式感。利用前俩个星期选课时间在寝室咸鱼。因白天不用调车，甚至觉得着生活比寒假都要轻松。温水在逐渐变烫，我这只青蛙也觉得压力慢慢变大。电磁的直立并不像摄像头的C+那样方法相对固定而又唯一，为了上速可以采取多种多样的方式：更改机械、改变电感的排布方案和算法、速度开环与闭环的选择、分段、模糊、串级、优化路径。没有人告诉你哪个是主要矛盾，哪条路好走，也没有人告诉你哪个方案到什么程度便该放弃。所以说下学期的路走的特别艰辛：一会儿找着串级大神聊天请教，一会儿发誓用一个星期亲手建个模糊表，一会儿又频繁刷着论坛看中南大佬如何调路径，因自身学习能力的欠缺和时间的限制我经历数次尝试，失败，再次尝试，再次失败，几度体验到绝望，几度在黑夜中啜泣。（那时候的晚上最喜欢明星是何炅，最喜欢看的综艺是《向往的生活》，最喜欢听的歌是金玟岐的姗姗）在上述这些都没搞通的同时，特殊元素的出现又让我们煞费苦心。校赛结束之后从弯入环岛开始，这个或大或小的圈便成了我们生活的重头戏：秉承着一次性搞完美的原则，起步便想拟合完美的路迹。当发现这种方法太过困难时，成功的在环上栽了第一个跟头。而后选择了做小改动然后不断优化，成功解决了弯接问题但成功率不高，它的简陋像定时炸弹一样埋在心底，让人总不心安。 16周结束，期末考试如期而至。这个学期有太多次惯性地通过在宿舍发呆来治愈方案频繁更换所带来的挫败感，做功课的时间寥寥无几，所以考试周的时候十分疲惫却又不得好处。熬完四门主要考试后就到了真正的冲刺阶段。10天的时间，来不及调整作息，从一整夜到18小时再到24小时，那段时间真的怀疑有失眠症这种东西,还以为亲身经历了马尔克斯的魔幻现实世界。现在想来，其实只是不甘罢。为了最后提速而加了速度环之后，之前的定时炸终于引爆。慌乱之中我们又尝试了全新的电感架法，不幸的是照搬效果欠佳。无奈帅锅硬件，宣布第三次改环以失败告终。这时已离封车不到一周，一次又一次的失败使我们乱了阵脚，所幸一年的历练让我们韧性大增，在可能的情况下尽着自己最大的努力。第三次环岛失败之后，我们回归原始摒弃各种束缚，去掉速度环，并将假闭环改为开环（虽说当时乱了阵脚后不易做大改动，但这痛定思痛后的决定在我现在开来还讲得通）。最后的效果如何我们并不清楚，因为已经没有时间再去尝试，因调试环岛而耽误了搓衣板，最后比赛只能放慢速。所幸最后一切顺利，结果均在预料之中，也算对这一年有一个交代。在智能车的这段日子里，流言蜚语不断，以致使我质疑加入这撸猫大队是否是个明智的选择。但一年完整经历下来（并不），自己认为十分值得。除了学习了一定控制领域的知识，更多的是明白了一些惯习的魅力：螺丝松了立马拧紧，温柔接车，下意识避开赛道，备份代码备份心情……还发现了自己所欠缺的：善良，合作，选择时的慎重，对自己该何时严格何时宽恕。 要克制自怜，更要将因抉择失误而产生的自悯，情绪尽量降低，唯有时刻保持清醒，才能看清真正的价值在哪里。 2018.7.26-2018.8.26在家中的这段时间得到了一定的放松，在世俗的生活里似乎也慢慢忘记了上个月的伤痛。时间永远是抚平伤痛最好的良药。见了几个挚友，回了一次老家，尝试了几次尽情的咸鱼，发现慢慢可以放下过去，继续往前行了，于是买了那本现在还在复习的单词书，当时每天早上都有在认真的背，怎奈事情繁多，时间太紧，还没背几个list就面临开学了。现在回想，这段时间里并没有给我带来什么，当时的想法也是把这段时间当作稍作歇息把，毕竟觉得人不可能永远紧绷着，需要一段时间停下了去看看过去的时光。 2018.8.26-2018.11.24作为这个学期的前半段阶段，诚然还是过的挺有规律的，虽然有些时候会做出一些令自己后悔的选择，但是总体来说，选择了考英语，选择了考研，选择了学校。有规律也有对自己的一定程度上的自信。但是当时有一件事情感觉对自己有一定影响的是去参加的物理竞赛吧。当时发现自己的一个特点，对不上心的东西做的并不是特别认真，一开始的时候，想通过一个简单的32机器人去检测自己一年所学的知识到了什么程度，但是做到一半发现自己心态开始转变，觉得这件事情很难通过一个人的力量来做到我想做的程度，并且认为这件事情也不是在我计划中最为关键的事情，于是慢慢放手，不再花太多经历在上面不打算花太多经历在上面，于是便有了之后的结果。 2018.11.24-2018.12.30这段时间里面，对自己的怀疑开始达到了顶峰，随着考试时间的逐渐接近，发现自己所学的东西并没有像之前自己想象的那么多。开始怀疑自己是否能够平衡英语的学习和专业课的学习，也开始怀疑自己是否有能力去考取高一时便订下机缘的大学。这段时间里面也努力渴求能找到一些东西把我从自我怀疑、自我贬低的深渊中拉出来。看过一个泪流满面的电影《无问西东》。“这个是世界缺的不是完美的人，而是从心底给出真心、正义、无畏与同情”。这句话让我产生了一定的勇气，只身一人去找了自己的两位导师。想要通过他们的帮助让自己走出泥淖。他们所给的建议便是自己给自己卸掉一定的压力，当然这和他们所处的年龄以及对我了解程度有一定的关系，不能全盘的吸收，还是要辨证的去看待他们所给的建议。所以说让我成为现在自己的原因，是这自己肩上的担子吗？ 我觉得并不是，我觉的最重要的是对自己的真实。“世俗这样强大，强大到生不出改变他们的念头来。可是无论外界的社会如何跌宕起伏，都对自己真诚，坚守原则，内心没了杂念和疑问，才能勇往直前”什么是对自己的真实？对自己的真实是指能认清真正值得自己。因为木心的“论事无涉私心意气谓之谦，命世不计个人得失谓之狂”而人有内心的膨胀和现实的自我贬低是不真实，看到身边的朋友活出了自己想要的模样而过分倾羡也是不真实，一口气拦下很多任务定出过高的目标也是不真实，总之，越是对自己不真实，就越容易陷入自我怀疑的泥淖。然而问题来了，基于现在的情况，我应该如何才能逐渐做到对接越来越真实呢？","categories":[],"tags":[{"name":"Study","slug":"Study","permalink":"http://example.com/tags/Study/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-13T08:23:16.000Z","updated":"2020-10-06T15:36:23.104Z","comments":true,"path":"2017/11/13/hello-world/","link":"","permalink":"http://example.com/2017/11/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Study","slug":"Study","permalink":"http://example.com/tags/Study/"}]}